<html>
<head>
    <script id="3d-vertex-shader" type="x-shader/x-vertex">
        precision highp float;

        attribute vec4 a_position;
        attribute vec2 a_texCoord;
        attribute vec3 a_normal;

        varying vec4 v_position;
        varying vec2 v_texCoord;
        varying vec3 v_normal;

        uniform mat4 u_projectionMatrix;
        uniform mat4 u_viewMatrix;
        uniform mat4 u_modelMatrix;

        void main() {
            v_texCoord = a_texCoord;
            v_normal = a_normal;

            v_position = u_viewMatrix * u_modelMatrix * a_position;
            gl_Position = u_projectionMatrix * v_position;
        }
    </script>
    <script id="3d-fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform sampler2D u_texture;

        uniform vec3 u_backgroundColor;

        varying vec4 v_position;
        varying vec2 v_texCoord;
        varying vec3 v_normal;

        uniform float u_fogStart;
        uniform float u_fogEnd;

        void main() {

            vec4 diffuse = texture2D(u_texture, v_texCoord);


            float direct = dot(v_normal, normalize(-vec3(-1.0,-1.5,-1.0))) * 0.3;
            

            //diffuse = vec4(v_normal * 0.5 + 0.5, 1.0);

            diffuse = vec4(diffuse.xyz * (direct + 0.6), diffuse.w);

            float dist = length(v_position.xyz);


            //gl_FragColor = vec4(mix(diffuse.xyz, u_backgroundColor, clamp((dist-96.0)/32.0, 0.0, 1.0)), diffuse.w);

            gl_FragColor = vec4(mix(diffuse.xyz, u_backgroundColor, clamp((dist-u_fogStart)/u_fogEnd, 0.0, 1.0)), diffuse.w);
        
            //gl_FragColor = vec4(v_normal * 0.5 + 0.5, 1.0);
        }
    </script>

    <script id="frustum-vertex-shader" type="x-shader/x-vertex">
        precision highp float;

        attribute vec4 a_position;

        uniform mat4 u_projectionMatrix;
        uniform mat4 u_viewMatrix;
        uniform mat4 u_modelMatrix;

        void main() {
            gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * a_position;
        }
    </script>
    <script id="frustum-fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec4 u_color;

        void main() {
            gl_FragColor = u_color;
        }
    </script>
    <style>
        * {padding: 0px; margin: 0px; }
        #canvas { width: 100%; height: 100%; position: absolute; }
        
        .debug { position: absolute; top: 4px; left: 4px; }
        .debug > div { background-color: rgba(255,255,255,0.7); padding: 5px; min-width: 10px; }

        #inventoryToolbar {
            border-radius: 10px; 
            display: flex; 
            position: absolute; 
            left: 50%; bottom: 0px; 
            background-color: rgba(0,0,0,0.7); 
            width: 480px; height: 60px; 
            margin-bottom: 10px; margin-left: -240px;
        }

        #inventoryMenu div:first-child .inventoryContainer:first-child { border-top-left-radius: 10px; }
        #inventoryMenu div:first-child .inventoryContainer:last-child { border-top-right-radius: 10px; }
        #inventoryMenu div:last-child .inventoryContainer:first-child { border-bottom-left-radius: 10px; }
        #inventoryMenu div:last-child .inventoryContainer:last-child { border-bottom-right-radius: 10px; }
        

        #inventoryToolbar .inventoryContainer:first-child {
            border-top-left-radius: 10px;
            border-bottom-left-radius: 10px;
        }

        #inventoryToolbar .inventoryContainer:last-child {
            border-top-right-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        .inventoryContainer {
            border: 5px solid #666666;
            margin: 0px;

            width: 50px; height: 50px;
        }

        .inventoryContainer.active {
            border: 5px solid #ffffff;
            margin: 0px;
        }

        .inventoryIcon {
            width: 32px; height: 32px;
            background-size: 1600%;
            background-position: -100% -100%;
            background-image: url('default.png');
            display: inline-block;
            image-rendering: pixelated;

            margin: 9px;

            color: #ffffff;
            font-weight: bold;
            font-family: monospace;
            text-align: right;
            text-shadow: -2px 0 black, 0 2px black, 1px 0 black, 0 -2px black;
            font-size: 15px;
        }

        #menu {
            display: none;
            border-radius: 10px; position: absolute; left: 50%; top: 50%; margin-left: -200px; margin-top: -75px; width: 400px; height: 150px; background-color: rgba(0,0,0,0.7);
        }

        #menu > div {
            line-height: 60px; text-align: center; font-size: 20pt; margin: 10px; padding: 0px 20px; border-radius: 10px; background-color: rgba(0,0,0,0.7); color: #ffffff
        }

        #menu > div:hover {
            background-color: rgba(17, 0, 65, 0.7);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="debug">
        <div id="position"></div>
        <div id="rotation"></div>
        <div id="cursor"></div>
        <br/>
        <div id="velocity"></div>
        <div id="acceleration"></div>
        <br/>
        <div id="renderedChunks"></div>
    </div>

    <div style="position: absolute; left: 50%; top:50%; width: 1px; height: 20px; margin-top: -10px; background-color: #000000;"></div>
    <div style="position: absolute; left: 50%; top:50%; width: 20px; height: 1px; margin-left: -10px; background-color: #000000;"></div>

    <div id="inventoryMenu" style="display: none; border-radius: 10px; position: absolute; bottom: 80px; width: 480px; height: 240px; left: 50%; margin-left: -240px; background-color: rgba(0,0,0,0.7);">
        <div style="display: flex;">
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
        </div>
        <div style="display: flex;">
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon">25</div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
        </div>
        <div style="display: flex;">
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
        </div>
        <div style="display: flex;">
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
            <div class="inventoryContainer"><div class="inventoryIcon"></div></div>
        </div>
    </div>

    <div id="inventoryToolbar">
        <div class="inventoryContainer active"><div class="inventoryIcon" style="background-position: -500% -100%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -200% -000%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -300% -000%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -400% -000%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -000% -200%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -100% -200%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -200% -200%;"></div></div>
        <div class="inventoryContainer"><div class="inventoryIcon" style="background-position: -200% -300%;"></div></div>
    </div>

    <div id="menu" style="display: none;">
        <div id="menu_save">Save</div>
        <div id="menu_continue">Continue</div>
    </div>

    <script>


        var UIDragging = null;
        var UICanDrop = false;
        var UIDragOffset;
        var UIDragElement = document.createElement("div");
        UIDragElement.className = "inventoryIcon";
        UIDragElement.style.position = "absolute";
        UIDragElement.style.margin = "0px";
        UIDragElement.style.pointerEvents = "none";
        UIDragElement.style.backgroundPosition = "-200% -000%";
        UIDragElement.style.display = "none";

        document.body.appendChild(UIDragElement);

        window.onmousemove = e => {
            if (UIDragging) {
                UIDragElement.style.left = (e.clientX - UIDragOffset[0]) + "px";
                UIDragElement.style.top = (e.clientY - UIDragOffset[1]) + "px";
            }
        }

        window.onmouseup = e => {
            UICanDrop = true;

            //console.log(e);
        }
        
        Array.from(document.querySelectorAll("#inventoryToolbar .inventoryContainer > .inventoryIcon")).forEach((element, index) => {
            element.inventoryIndex = index;
        });

        Array.from(document.querySelectorAll("#inventoryMenu .inventoryContainer > .inventoryIcon")).forEach((element, index) => {
            element.inventoryIndex = index + 8;
        });

        Array.from(document.querySelectorAll(".inventoryContainer > .inventoryIcon")).forEach(element => {
            element.onmousedown = function(e) {
                if (UIDragging) return;

                //console.log(element.inventoryIndex);


                UIDragging = {id: activePlayer.inventory[element.inventoryIndex]};
                UICanDrop = false;
                UIDragOffset = [e.offsetX, e.offsetY];

                activePlayer.inventory[element.inventoryIndex] = null;

                UIDragElement.style.display = "";
                UIDragElement.style.backgroundPosition = this.style.backgroundPosition;
                UIDragElement.style.left = (e.clientX - UIDragOffset[0]) + "px";
                UIDragElement.style.top = (e.clientY - UIDragOffset[1]) + "px";
                UIDragElement.innerText = this.innerText;

                this.style.display = "none";
            }

            element.parentNode.inventoryItem = element;
        });

        Array.from(document.getElementsByClassName("inventoryContainer")).forEach(element => {
            element.onmousedown = function(e) {

                if (UIDragging && UICanDrop) {

                    if (element.inventoryItem.style.display == "none") {
                        element.inventoryItem.style.display = "";
                        element.inventoryItem.style.backgroundPosition = UIDragElement.style.backgroundPosition;
                        element.inventoryItem.innerText = UIDragElement.innerText;

                        activePlayer.inventory[element.inventoryItem.inventoryIndex] = UIDragging.id;

                        UIDragging = null;
                        UIDragElement.style.display = "none";
                    } else {
                        const oldPosition = element.inventoryItem.style.backgroundPosition;
                        const oldCount = element.inventoryItem.innerText;
                        const oldItemId = activePlayer.inventory[element.inventoryItem.inventoryIndex];

                        activePlayer.inventory[element.inventoryItem.inventoryIndex] = UIDragging.id;
                        UIDragging = {id: oldItemId};

                        element.inventoryItem.style.display = "";
                        element.inventoryItem.style.backgroundPosition = UIDragElement.style.backgroundPosition;
                        element.inventoryItem.innerText = UIDragElement.innerText;

                        UIDragElement.style.backgroundPosition = oldPosition;
                        UIDragElement.innerText = oldCount;
                    }
                }

                
            }
        });

        function setActiveItem(ndx) {
            var index = 0;

            document.getElementById("inventoryToolbar").childNodes.forEach(val => {
                if (val.tagName == "DIV") {
                    val.className = index == ndx ? "inventoryContainer active" : "inventoryContainer";
                    index++;
                }
            });
        }

        document.getElementById("menu_continue").onclick = e => {
            document.getElementById("menu").style.display = "none";
            canvas.requestPointerLock();
        }

        document.getElementById("menu_save").onclick = e => {
            world.save();
        }


        var mat4 = {
            getIdentity: function() {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0 ,1, 0,
                    0, 0, 0, 1];
            },
            getProjection: function(aspect, fov, near, far) {
                var f = 1.0/Math.tan(fov/2.0);
                return [
                    f/aspect, 0.0,                       0.0,  0.0,
                    0.0     ,   f,                       0.0,  0.0,
                    0.0     , 0.0,     (far+near)/(near-far), -1.0,
                    0.0     , 0.0, (2.0*far*near)/(near-far),  0.0];
            },
            getXRotation: function(rotation) {
                return [
                    1                  , 0                 , 0, 0,
                    0,  Math.cos(rotation), Math.sin(rotation), 0,
                    0, -Math.sin(rotation), Math.cos(rotation), 0,
                    0, 0                  , 0                 , 1];
            },
            getYRotation: function(rotation) {
                return [
                    Math.cos(rotation), 0, Math.sin(rotation), 0,
                                0, 1,             0, 0,
                    -Math.sin(rotation), 0, Math.cos(rotation), 0,
                                0, 0,             0, 1];
            },
            getScale: function(x, y, z) {
                return [
                    x,0,0,0,
                    0,y,0,0,
                    0,0,z,0,
                    0,0,0,1];
            },
            getTranslate: function(x, y, z) {
                return [
                    1,0,0,0,
                    0,1,0,0,
                    0,0,1,0,
                    x,y,z,1];
            },
            multiply: function(l, r) {
                if (r.length == 4) {
                    return [
                        l[0] * r[0] + l[4] * r[1] + l[ 8] * r[2] + l[12] * r[3],
                        l[1] * r[0] + l[5] * r[1] + l[ 9] * r[2] + l[13] * r[3],
                        l[2] * r[0] + l[6] * r[1] + l[10] * r[2] + l[14] * r[3],
                        l[3] * r[0] + l[7] * r[1] + l[11] * r[2] + l[15] * r[3]
                    ];
                }

                return [
                    l[ 0] * r[0] + l[ 1] * r[4] + l[ 2] * r[ 8] + l[ 3] * r[12],
                    l[ 0] * r[1] + l[ 1] * r[5] + l[ 2] * r[ 9] + l[ 3] * r[13],
                    l[ 0] * r[2] + l[ 1] * r[6] + l[ 2] * r[10] + l[ 3] * r[14],
                    l[ 0] * r[3] + l[ 1] * r[7] + l[ 2] * r[11] + l[ 3] * r[15],

                    l[ 4] * r[0] + l[ 5] * r[4] + l[ 6] * r[ 8] + l[ 7] * r[12],
                    l[ 4] * r[1] + l[ 5] * r[5] + l[ 6] * r[ 9] + l[ 7] * r[13],
                    l[ 4] * r[2] + l[ 5] * r[6] + l[ 6] * r[10] + l[ 7] * r[14],
                    l[ 4] * r[3] + l[ 5] * r[7] + l[ 6] * r[11] + l[ 7] * r[15],

                    l[ 8] * r[0] + l[ 9] * r[4] + l[10] * r[ 8] + l[11] * r[12],
                    l[ 8] * r[1] + l[ 9] * r[5] + l[10] * r[ 9] + l[11] * r[13],
                    l[ 8] * r[2] + l[ 9] * r[6] + l[10] * r[10] + l[11] * r[14],
                    l[ 8] * r[3] + l[ 9] * r[7] + l[10] * r[11] + l[11] * r[15],

                    l[12] * r[0] + l[13] * r[4] + l[14] * r[ 8] + l[15] * r[12],
                    l[12] * r[1] + l[13] * r[5] + l[14] * r[ 9] + l[15] * r[13],
                    l[12] * r[2] + l[13] * r[6] + l[14] * r[10] + l[15] * r[14],
                    l[12] * r[3] + l[13] * r[7] + l[14] * r[11] + l[15] * r[15]
                ];
            },
            transpose: function(i) {
                return [
                    i[0], i[4], i[ 8], i[12],
                    i[1], i[5], i[ 9], i[13],
                    i[2], i[6], i[10], i[14],
                    i[3], i[7], i[11], i[15],
                ]
            },
            fromQuaternion: function(q) {
                let x = q[0];
                let y = q[1];
                let z = q[2];
                let w = q[3];

                const sqw = w * w;
                const sqx = x * x;
                const sqy = y * y;
                const sqz = z * z;

                // invs (inverse square length) is only required if quaternion is not already normalised
                const invs = 1 / (sqx + sqy + sqz + sqw)
                m00 = ( sqx - sqy - sqz + sqw) * invs;
                m11 = (-sqx + sqy - sqz + sqw) * invs;
                m22 = (-sqx - sqy + sqz + sqw) * invs;
                
                let tmp1 = x * y;
                let tmp2 = z * w;
                m10 = 2.0 * (tmp1 + tmp2) * invs;
                m01 = 2.0 * (tmp1 - tmp2) * invs;
                
                tmp1 = x * z;
                tmp2 = y * w;
                m20 = 2.0 * (tmp1 - tmp2) * invs;
                m02 = 2.0 * (tmp1 + tmp2) * invs;

                tmp1 = y * z;
                tmp2 = x * w;
                m21 = 2.0 * (tmp1 + tmp2) * invs;
                m12 = 2.0 * (tmp1 - tmp2) * invs;

                return [
                    m00, m10, m20, 0,
                    m01, m11, m21, 0,
                    m02, m12, m22, 0,
                    0  , 0  , 0  , 1
                ];
            },
            inverse: function(m) {
                var result = [
                    0,0,0,0,  
                    0,0,0,0,  
                    0,0,0,0,   
                    0,0,0,0];

                result[0] = m[5]  * m[10] * m[15] - 
                            m[5]  * m[11] * m[14] - 
                            m[9]  * m[6]  * m[15] + 
                            m[9]  * m[7]  * m[14] +
                            m[13] * m[6]  * m[11] - 
                            m[13] * m[7]  * m[10];

                result[4] = -m[4]  * m[10] * m[15] + 
                            m[4]  * m[11] * m[14] + 
                            m[8]  * m[6]  * m[15] - 
                            m[8]  * m[7]  * m[14] - 
                            m[12] * m[6]  * m[11] + 
                            m[12] * m[7]  * m[10];

                result[8] = m[4]  * m[9] * m[15] - 
                            m[4]  * m[11] * m[13] - 
                            m[8]  * m[5] * m[15] + 
                            m[8]  * m[7] * m[13] + 
                            m[12] * m[5] * m[11] - 
                            m[12] * m[7] * m[9];

                result[12] = -m[4]  * m[9] * m[14] + 
                            m[4]  * m[10] * m[13] +
                            m[8]  * m[5] * m[14] - 
                            m[8]  * m[6] * m[13] - 
                            m[12] * m[5] * m[10] + 
                            m[12] * m[6] * m[9];

                result[1] = -m[1]  * m[10] * m[15] + 
                            m[1]  * m[11] * m[14] + 
                            m[9]  * m[2] * m[15] - 
                            m[9]  * m[3] * m[14] - 
                            m[13] * m[2] * m[11] + 
                            m[13] * m[3] * m[10];

                result[5] = m[0]  * m[10] * m[15] - 
                            m[0]  * m[11] * m[14] - 
                            m[8]  * m[2] * m[15] + 
                            m[8]  * m[3] * m[14] + 
                            m[12] * m[2] * m[11] - 
                            m[12] * m[3] * m[10];

                result[9] = -m[0]  * m[9] * m[15] + 
                            m[0]  * m[11] * m[13] + 
                            m[8]  * m[1] * m[15] - 
                            m[8]  * m[3] * m[13] - 
                            m[12] * m[1] * m[11] + 
                            m[12] * m[3] * m[9];

                result[13] = m[0]  * m[9] * m[14] - 
                            m[0]  * m[10] * m[13] - 
                            m[8]  * m[1] * m[14] + 
                            m[8]  * m[2] * m[13] + 
                            m[12] * m[1] * m[10] - 
                            m[12] * m[2] * m[9];

                result[2] = m[1]  * m[6] * m[15] - 
                            m[1]  * m[7] * m[14] - 
                            m[5]  * m[2] * m[15] + 
                            m[5]  * m[3] * m[14] + 
                            m[13] * m[2] * m[7] - 
                            m[13] * m[3] * m[6];

                result[6] = -m[0]  * m[6] * m[15] + 
                            m[0]  * m[7] * m[14] + 
                            m[4]  * m[2] * m[15] - 
                            m[4]  * m[3] * m[14] - 
                            m[12] * m[2] * m[7] + 
                            m[12] * m[3] * m[6];

                result[10] = m[0]  * m[5] * m[15] - 
                            m[0]  * m[7] * m[13] - 
                            m[4]  * m[1] * m[15] + 
                            m[4]  * m[3] * m[13] + 
                            m[12] * m[1] * m[7] - 
                            m[12] * m[3] * m[5];

                result[14] = -m[0]  * m[5] * m[14] + 
                            m[0]  * m[6] * m[13] + 
                            m[4]  * m[1] * m[14] - 
                            m[4]  * m[2] * m[13] - 
                            m[12] * m[1] * m[6] + 
                            m[12] * m[2] * m[5];

                result[3] = -m[1] * m[6] * m[11] + 
                            m[1] * m[7] * m[10] + 
                            m[5] * m[2] * m[11] - 
                            m[5] * m[3] * m[10] - 
                            m[9] * m[2] * m[7] + 
                            m[9] * m[3] * m[6];

                result[7] = m[0] * m[6] * m[11] - 
                            m[0] * m[7] * m[10] - 
                            m[4] * m[2] * m[11] + 
                            m[4] * m[3] * m[10] + 
                            m[8] * m[2] * m[7] - 
                            m[8] * m[3] * m[6];

                result[11] = -m[0] * m[5] * m[11] + 
                            m[0] * m[7] * m[9] + 
                            m[4] * m[1] * m[11] - 
                            m[4] * m[3] * m[9] - 
                            m[8] * m[1] * m[7] + 
                            m[8] * m[3] * m[5];

                result[15] = m[0] * m[5] * m[10] - 
                            m[0] * m[6] * m[9] - 
                            m[4] * m[1] * m[10] + 
                            m[4] * m[2] * m[9] + 
                            m[8] * m[1] * m[6] - 
                            m[8] * m[2] * m[5];

                var det = m[0] * result[0] + m[1] * result[4] + m[2] * result[8] + m[3] * result[12];

                if (det == 0) throw "No inverse for matrix could be found";

                det = 1.0 / det;

                for (i = 0; i < 16; i++)
                    result[i] = result[i] * det;

                return result;

            }
        };

        var vec2 = {
            subtract: function(l,r) {
                return [l[0]-r[0], l[1]-r[1]];
            },
            length: function(v) {
                return Math.hypot(v[0], v[1]);
            },
            cross: function(a, b) {
                return a[0] * b[1] - b[0] * a[1];
            }
        }

        var vec3 = {
            add: function(l,r) {
                return [l[0]+r[0], l[1]+r[1], l[2]+r[2]];
            },
            subtract: function(l,r) {
                return [l[0]-r[0], l[1]-r[1], l[2]-r[2]];
            },
            divide: function(l,r) {
                if (Array.isArray(r)) return [l[0]/r[0], l[1]/r[1], l[2]/r[2]];
                return [l[0]/r, l[1]/r, l[2]/r];
            },
            multiply: function(l,r) {
                if (Array.isArray(r)) return [l[0]*r[0], l[1]*r[1], l[2]*r[2]];
                return [l[0]*r, l[1]*r, l[2]*r];
            },
            lerp: function(a, b, t) {
                return [
                    a[0] + ((b[0] - a[0]) * t),
                    a[1] + ((b[1] - a[1]) * t),
                    a[2] + ((b[2] - a[2]) * t)
                ];
            }
        }
    </script>
    <script src="perlin.js"></script>
    <script>
        function createShader(ctx, type, id) {
            var result = ctx.createShader(type);
            ctx.shaderSource(result, document.getElementById(id).innerText);
            ctx.compileShader(result);

            var info = ctx.getShaderInfoLog(result);
            if (info) console.log(info);

            return result;
        }

        function createProgram(ctx, vertexShaderId, fragmentShaderId) {
            var vertexShader = createShader(ctx, ctx.VERTEX_SHADER, vertexShaderId);
            var fragmentShader = createShader(ctx, ctx.FRAGMENT_SHADER, fragmentShaderId);

            var program = ctx.createProgram();
            ctx.attachShader(program, vertexShader);
            ctx.attachShader(program, fragmentShader);
            ctx.linkProgram(program);

            var info = ctx.getProgramInfoLog(program);
            if (info) console.log(info);

            return program;
        }

        function encodeSimpleRLE(data) {
            var packedChunk = "";

            var curValue = -1;
            var valueCount = 0;
            data.forEach(val => {
                if (curValue == val) {
                    valueCount++;
                } else {
                    if (valueCount > 0)
                        packedChunk += valueCount.toString(16) + "x" + curValue.toString(16) + ",";

                    valueCount = 1;
                    curValue = val;
                }
            })

            if (valueCount > 0)
                packedChunk += valueCount.toString(16) + "x" + curValue.toString(16) + ",";

            return packedChunk;
        }

        function decodeSimpleRLE(str) {
            var result = [];

            str.split(",").forEach(item => {
                var lenVal = item.split("x");

                if (lenVal.length == 2) {
                    const length = parseInt(lenVal[0], 16);
                    const val = parseInt(lenVal[1], 16);

                    for (var i=0; i<length;i++) result.push(val);
                }
            });

            return result;
        }


        var canvas = document.getElementById("canvas");
        var gl = canvas.getContext("webgl", {alpha: false, stencil: true});

        var program = createProgram(gl, "3d-vertex-shader", "3d-fragment-shader");
        program.a_position = gl.getAttribLocation(program, "a_position");
        program.a_texCoord = gl.getAttribLocation(program, "a_texCoord");
        program.a_normal = gl.getAttribLocation(program, "a_normal");
        program.u_projectionMatrix = gl.getUniformLocation(program, "u_projectionMatrix");
        program.u_viewMatrix = gl.getUniformLocation(program, "u_viewMatrix");
        program.u_modelMatrix = gl.getUniformLocation(program, "u_modelMatrix");
        program.u_backgroundColor = gl.getUniformLocation(program, "u_backgroundColor");

        program.u_fogStart = gl.getUniformLocation(program, "u_fogStart");
        program.u_fogEnd = gl.getUniformLocation(program, "u_fogEnd");

        gl.useProgram(program);
        gl.uniform1f(program.u_fogStart, 96.0);
        gl.uniform1f(program.u_fogEnd, 64.0);



        var frustumProgram = createProgram(gl, "frustum-vertex-shader", "frustum-fragment-shader");
        frustumProgram.a_position = gl.getAttribLocation(frustumProgram, "a_position");
        frustumProgram.u_projectionMatrix = gl.getUniformLocation(frustumProgram, "u_projectionMatrix");
        frustumProgram.u_viewMatrix = gl.getUniformLocation(frustumProgram, "u_viewMatrix");
        frustumProgram.u_modelMatrix = gl.getUniformLocation(frustumProgram, "u_modelMatrix");
        frustumProgram.u_color = gl.getUniformLocation(frustumProgram, "u_color");
        

        window.onresize = () => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            gl.viewport(0,0,canvas.width, canvas.height);
        };

        window.onresize();

        

        

        
        


        var blockTypes = [
            { name: "air", block: false },
            { name: "bedrock", block: true, image: 17 },
            { name: "stone", block: true, image: 1 },
            { name: "coblestone", block: true, image: 16 },
            { name: "dirt", block: true, image: 2 },
            { name: "grass", block: true, image: [10*16 + 9, 3, 3, 3, 3, 2] },
            { name: "planks", block: true, image: 4 },
            { name: "bricks", block: true, image: 7 },

            { name: "tree", block: true, image: [21,20,20,20,20,21] },
            { name: "leafes", block: true, image: 3*16 + 4 },
            { name: "coalore", block: true, image: 2*16 + 2 },
            { name: "ironore", block: true, image: 2*16 + 1 },
            { name: "goldore", block: true, image: 2*16 + 0 },
            { name: "diamondore", block: true, image: 3*16 + 2 },
            { name: "redstoneore", block: true, image: 3*16 + 3 },

            { name: "tnt", block: true, image: [9,8,8,8,8,10]},
            { name: "netherrock", block: true, image: 6*16 + 7},
            { name: "obsidian", block: true, image: 11*16 + 7},
            { name: "lava", block: false, liquid: true, image: 14*16 + 13 },
            { name: "water", block: false, liquid: true, image: 12*16 + 13},
            { name: "glass", block: true, image: 3*16 + 1},
            { name: "chest", block: true, image: [25, 27, 26, 26, 26, 25]},
            { name: "workbench", block: true, image: [43, 59, 59, 59, 59, 4]},
            { name: "furnace", block: true, image: [62,44,45,45,45,62]},
        ];

        // convert single image to 6 sided array
        blockTypes.forEach(blockType => {
            if (!Array.isArray(blockType.image)) {
                blockType.image = [blockType.image, blockType.image, blockType.image, blockType.image, blockType.image, blockType.image];
            }

            blockType.iconImage = blockType.image[1];
        });

        // cleanup atlas
        let nextNewImage = 0;
        let blockTypeImageMap = [];

        blockTypes.forEach(blockType => {
            blockType.image = blockType.image.map(imageIndex => {
                if (imageIndex == undefined) return;

                if (blockTypeImageMap[imageIndex] == undefined) {
                    blockTypeImageMap[imageIndex] = nextNewImage++;
                }

                return blockTypeImageMap[imageIndex];
            });
        });


        function loadSkin(image) {
            var result = gl.createTexture();
            let img = new Image();
            img.src = image;
            img.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, result);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            }

            return result;
        }


        var atlas = gl.createTexture();
        const atlasBorder = 6;
        const atlasSize = 256;
        const atlasItemSize = 16 + atlasBorder + atlasBorder;
        const atlasPerRow = Math.floor(atlasSize / atlasItemSize);
        const atlasPixel = 1/atlasSize;

        var img = new Image();
        img.src = "default.png";
        img.onload = () => {

            let atlasCanvas = document.createElement("canvas");
            atlasCanvas.width = atlasSize;
            atlasCanvas.height = atlasSize;

            //atlasCanvas.style = "width: 256px; height: 256px; right: 0px; top: 0px; position: absolute; image-rendering: pixelated;";
            //document.body.appendChild(atlasCanvas);

            atlasContext = atlasCanvas.getContext("2d");
            atlasContext.imageSmoothingEnabled = false;

            blockTypeImageMap.forEach((dst, src) => {
                srcX = (src % 16) * 16;
                srcY = (Math.floor(src / 16)) * 16;
                dstX = (dst % atlasPerRow) * atlasItemSize;
                dstY = (Math.floor(dst / atlasPerRow)) * atlasItemSize;


                atlasContext.drawImage(img, srcX   , srcY   , 16, 16,   dstX + atlasBorder     , dstY + atlasBorder     ,          16,          16);

                atlasContext.drawImage(img, srcX   , srcY   , 16, 1 ,   dstX + atlasBorder     , dstY                   ,          16, atlasBorder);
                atlasContext.drawImage(img, srcX   , srcY+15, 16, 1 ,   dstX + atlasBorder     , dstY + atlasBorder + 16,          16, atlasBorder);
                atlasContext.drawImage(img, srcX   , srcY   ,  1, 16,   dstX                   , dstY + atlasBorder     , atlasBorder,          16);
                atlasContext.drawImage(img, srcX+15, srcY   ,  1, 16,   dstX + atlasBorder + 16, dstY + atlasBorder     , atlasBorder,          16);

                atlasContext.drawImage(img, srcX   , srcY   ,  1,  1,   dstX                   , dstY                   , atlasBorder, atlasBorder);
                atlasContext.drawImage(img, srcX+15, srcY   ,  1,  1,   dstX + atlasBorder + 16, dstY                   , atlasBorder, atlasBorder);
                atlasContext.drawImage(img, srcX   , srcY+15,  1,  1,   dstX                   , dstY + atlasBorder + 16, atlasBorder, atlasBorder);
                atlasContext.drawImage(img, srcX+15, srcY+15,  1,  1,   dstX + atlasBorder + 16, dstY + atlasBorder + 16, atlasBorder, atlasBorder);
            });



            gl.bindTexture(gl.TEXTURE_2D, atlas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
            //gl.generateMipmap(gl.TEXTURE_2D);
        }


        const ENTITY_TYPE_ITEM = 1;
        const ENTITY_TYPE_PLAYER = 2;

        let defaultPlayer = {
            name: "Player",
            skin: loadSkin("skins/steve.png"),
            type: ENTITY_TYPE_PLAYER,
            pos: {x: 0, y: 0, z: 0},
            rotation: {pitch: 0, yaw: 0},
            acceleration: { x: 0, y: 0, z: -35.0},
            velocity: { x: 0, y: 0, z: 0},
            standing: false,
            inventory: [ 8,  4,    5,    6,   12,   21,   22,   23,
                         2,  3,    4,    5,    6,    7,    8, null,
                         9, 10,   11,   12,   13,   14, null, null,
                        15, 16,   17,   18,   19,   20,   21, null,
                        22, 23, null, null, null, null, null, null],
            activeItem: 0,
            height: 1.8,
            radius: 0.4,
            eyeHeight: 1.65
        }

        defaultPlayer.inventory = defaultPlayer.inventory.map(blockType => {
            return blockType ? {blockType: blockType, blockCount: 10} : null
        });

        let otherPlayer = {
            name: "The other one",
            skin: loadSkin("skins/alex.png"),
            type: ENTITY_TYPE_PLAYER,
            pos: {x: 0, y: -5, z: 0},
            rotation: {pitch: 0, yaw: 0},
            acceleration: { x: 0, y: 0, z: -35.0},
            velocity: { x: 0, y: 0, z: 0},
            standing: false,
            inventory: [null, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null],
            activeItem: 0,
            height: 1.8,
            radius: 0.4,
            eyeHeight: 1.65
        }

        let entities = [
            defaultPlayer,
            otherPlayer,
        ];

        function makeGifts() {
            [2,3,6,7,8,15,17,21,22,23].forEach((blockType, index) => {
                entities.push({
                    type: ENTITY_TYPE_ITEM,
                    pos: {x: activePlayer.pos.x + (index-4), y: activePlayer.pos.y+15, z: activePlayer.pos.z + 5},
                    rotation: {pitch: 0, yaw: 0},
                    acceleration: { x: 0, y: 0, z: -30.0},
                    velocity: { x: 0, y: 0, z: 0},
                    height: 0.4,
                    radius: 0.2,
                    blockType: blockType,
                    blockCount: 64
                });
            })
        }

        

        let activePlayer = defaultPlayer;

        makeGifts();

        function updateUI() {
            Array.from(document.querySelectorAll(".inventoryContainer .inventoryIcon")).forEach((icon, index) => {

                const item = activePlayer.inventory[icon.inventoryIndex];
                if (item) {
                    const itemDef = blockTypes[item.blockType];

                    const backgroundPositionX = itemDef.iconImage % 16;
                    const backgroundPositionY = Math.floor(itemDef.iconImage / 16);

                    icon.innerText = item.blockCount;
                    icon.style.display = "";
                    icon.style.backgroundPosition = "-" + backgroundPositionX + "00% -" + backgroundPositionY + "00%";
                } else {
                    icon.style.display = "none";
                }
            });
        }

        updateUI();

        
        const perlin = new Perlin();

        const posOffset = (x,y,z) => z * 256 + y * 16 + x;

        function createNetherChunk(x, y) {
            var result = {
                x: x, y: y,
                elementCount: 0,
                dirty: true,
                saved: true,
                buffer: gl.createBuffer(),
                data: []
            };

            // bedrock layer
            for (var j=0; j<16*16; j++) {
                result.data.push(1);
            }

            var extraLayer = 127 - (result.data.length / (16*16));
            for (var i=0; i<extraLayer; i++) {

                for (var j=0; j<16*16; j++) {
                    result.data.push(0);
                }

            }

            for (var x2=0; x2<16; x2++)
            for (var y2=0; y2<16; y2++)
            for (var z2=1; z2<127; z2++) {

                

                const realX = x*16+x2;
                const realY = y*16+y2;

                var val = perlin.get(realX * 0.1, realY * 0.1, z2 * 0.1);

                var factor = Math.min(0.6, Math.pow( Math.min(z2, 127-z2),2)/400);
                
                //=MIN(POW(MIN(A1,127-A1),2)/400, 0.6)


                if (val > factor) {
                    result.data[posOffset(x2,y2,z2)] = 16;
                } else {
                    if (z2 < 20) {
                        result.data[posOffset(x2,y2,z2)] = 18;
                    }
                }
            }

            // bedrock layer
            for (var j=0; j<16*16; j++) {
                result.data.push(1);
            }

            return result;
        }


        function createChunk(x, y) {
            var result = {
                x: x, y: y,
                elementCount: 0,
                dirty: true,
                saved: true,
                buffer: gl.createBuffer(),
                data: []
            };

            // bedrock layer
            for (var j=0; j<16*16; j++) {
                result.data.push(1);
            }

            var extraLayer = 128 - (result.data.length / (16*16));
            for (var i=0; i<extraLayer; i++) {

                for (var j=0; j<16*16; j++) {
                    result.data.push(0);
                }

            }

            for (var x2=0; x2<16; x2++)
            for (var y2=0; y2<16; y2++) {

                const realX = x*16+x2;
                const realY = y*16+y2;

                //const height = Math.floor(perlin.get(realX*0.05,realY*0.05,0.5) * 10)+25;

                //var height = perlin.get(realX*0.005,realY*0.005,0.5);
                //height += (perlin.get(realX * 0.05, realY * 0.05, 0.5) - 0.5) * 0.2;

                //height = Math.floor(height*80)+10;
                var multiply = 0.005;
                var multiply2 = 0.04;
                var rough = perlin.get(realX * multiply,realY * multiply, 0.5);
                rough += (perlin.get(realX * multiply2, realY * multiply2, 0.5) - 0.5) * 0.2;
                
                rough = Math.max(Math.min((rough-0.5) * 10, 1.0), 0.0);

                var noGrass = rough > 0.05 && rough < 0.95;

                rough += (perlin.get(realX * multiply2, realY * multiply2, 0.5) - 0.5) * 0.2;

                var height = rough * 50 + 4;

                height = Math.floor(height);

                for (var i=0; i<height; i++) {
                    result.data[posOffset(x2,y2,i+1)] = 2;
                }
                result.data[posOffset(x2,y2,height+1)] = noGrass ? 2 : 4;
                result.data[posOffset(x2,y2,height+2)] = noGrass ? 2 : 4;
                result.data[posOffset(x2,y2,height+3)] = noGrass ? 2 : 5;
            }

            for (var x2=0; x2<16; x2++)
            for (var y2=0; y2<16; y2++)
            for (var z2=0; z2<64; z2++) {

                if (result.data[posOffset(x2,y2,z2)] != 2)  continue;

                const realX = x*16+x2;
                const realY = y*16+y2;

                var val = perlin.get(realX * 0.1, realY * 0.1, z2 * 0.1);

                if (val > 0.8) {
                    result.data[posOffset(x2,y2,z2)] = 10;
                } 
            }

            return result;
        }

        function createMinimalChunk(x, y) {
            var result = {
                x: x, y: y,
                elementCount: 0,
                dirty: true,
                saved: true,
                buffer: gl.createBuffer(),
                data: []
            };

            // bedrock layer
            for (var j=0; j<16*16; j++) {
                result.data.push(1);
            }

            // air layers
            for (var i=0; i<127; i++) {
                for (var j=0; j<16*16; j++) {
                    result.data.push(0);
                }
            }

            return result;
        }



        function World(id, worldFactory, backgroundColor) {
            this.chunks = [];
            this.id = id;
            this.worldFactory = worldFactory;
            this.backgroundColor = backgroundColor;
            this.loadingList = [{x:0, y:0}];
        };
        World.prototype.tryFindChunk = function(x, y) {
            x = Math.floor(x); y = Math.floor(y);

            var result = this.chunks.find(chunk => chunk.x == x && chunk.y == y);
            return result;
        }

        World.prototype.findChunk = function(x, y) {
            x = Math.floor(x); y = Math.floor(y);

            var result = this.chunks.find(chunk => chunk.x == x && chunk.y == y);

            


            if (!result) {
                

                //result = this.worldFactory(x, y);

                var storeKey = "chunk|" + this.id + "|" + x.toString(16) + "|" + y.toString(16);
                const storedData = localStorage.getItem(storeKey);

                if (storedData) {
                    result = {
                        x: x, y: y,
                        dirty: true,
                        saved: true,
                        data: decodeSimpleRLE(storedData),
                        elementCount: 0,
                        buffer: gl.createBuffer(),
                    }
                } else {
                    if (Math.abs(x) > 3 || Math.abs(y) > 3) {

                        const alreadyLoading = this.loadingList.some(val => val.x == x && val.y == y);


                        if (!alreadyLoading) {
                            this.loadingList.push({x:x, y:y});
                            backgroundWorker.postMessage({function:"createChunk", parameters: [x, y], tag: 32});
                        }
                        

                        return null;
                    }

                    result = this.worldFactory(x, y);
                }

                this.chunks.push(result);
            }
            return result;
        }

        World.prototype.getBlock = function(x, y, z) {
            const chunkX = Math.floor(x/16);
            const chunkY = Math.floor(y/16);

            var chunk = world.findChunk(chunkX, chunkY);

            const blaX = x - chunkX*16;
            const blaY = y - chunkY*16;

            const offset = posOffset(blaX, blaY, z);

            return chunk.data[offset];
        }

        World.prototype.setBlock = function(x, y, z, blockType) {
            const chunkX = Math.floor(x/16);
            const chunkY = Math.floor(y/16);

            var chunk = world.findChunk(chunkX, chunkY);

            const blaX = x - chunkX*16;
            const blaY = y - chunkY*16;

            const offset = posOffset(blaX, blaY, z);
            if (chunk.data[offset] != blockType) {
                chunk.data[offset] = blockType;
                chunk.dirty = true;
                chunk.saved = false;

                if (blaX == 0) {
                    const leftChunk = world.tryFindChunk(chunkX-1, chunkY);
                    if (leftChunk) leftChunk.dirty = true;
                }

                if (blaX == 15) {
                    const rightChunk = world.tryFindChunk(chunkX+1, chunkY);
                    if (rightChunk) rightChunk.dirty = true;
                }
                
                if (blaY == 0) {
                    const backChunk = world.tryFindChunk(chunkX, chunkY-1);
                    if (backChunk) backChunk.dirty = true;
                }

                if (blaY == 15) {
                    const frontChunk = world.tryFindChunk(chunkX, chunkY+1);
                    if (frontChunk) frontChunk.dirty = true;
                }

                return true;
            }

            return false;
        }

        World.prototype.save = function() {
            this.chunks.filter(chunk => !chunk.saved).forEach(chunk => {
                var storeKey = "chunk|" + this.id + "|" + chunk.x.toString(16) + "|" + chunk.y.toString(16);
                localStorage.setItem(storeKey, encodeSimpleRLE(chunk.data));
            });
        }


        var world = new World(0, createChunk, [0, 0.75, 1.0]);
        //var world = new World(0, createMinimalChunk, [0, 0.75, 1.0]);
        var nether = new World(1, createNetherChunk, [0, 0, 0]);
        

        var backgroundWorker = new Worker('worker.js');
        backgroundWorker.onmessage = function(e) {
            e.data.result.elementCount = 0;
            e.data.result.dirty = true;
            e.data.result.saved = true;
            e.data.result.buffer = gl.createBuffer();

            world.chunks.push(e.data.result);
        }

        
        /*
        const texScale = 1/16;

        function calcTextureOffsets(image, output) {
            const a = Math.floor(image/16);
            const b = image%16;

            output.ax = texScale*(b  );
            output.ay = texScale*(a  );

            output.bx = texScale*(b+1);
            output.by = texScale*(a+1);
        }*/




        function calcTextureOffsets(image, output) {
            const a = (Math.floor(image / atlasPerRow)) * atlasItemSize;
            const b = (image % atlasPerRow) * atlasItemSize;

            output.ax = atlasPixel * (b + atlasBorder);
            output.ay = atlasPixel * (a + atlasBorder);

            output.bx = atlasPixel * (b + atlasBorder + 16);
            output.by = atlasPixel * (a + atlasBorder + 16);
        }
        
        function updateChunkBuffer(chunk) {
            var meshData = [];
            let textureOffset = {};

            const leftChunk = world.findChunk(chunk.x - 1, chunk.y);
            const rightChunk = world.findChunk(chunk.x + 1, chunk.y);

            const frontChunk = world.findChunk(chunk.x, chunk.y + 1);
            const backChunk = world.findChunk(chunk.x, chunk.y - 1);
            
            if (!leftChunk || !rightChunk || !frontChunk || !backChunk) return false;

            for (var z=0;z<128;z++) {
                for (var y=0;y<16;y++) {
                    for (var x=0;x<16;x++) {
                    
                        const blockTypeInfo = blockTypes[chunk.data[posOffset(x,y,z)]];
                        


                        
                        if (blockTypeInfo.block) {
                            // Top
                            if (z == 127 || !blockTypes[chunk.data[posOffset(x,y,z+1)]].block) {
                                calcTextureOffsets(blockTypeInfo.image[0], textureOffset);
                                meshData.push(
                                    x + 0,  z+1,  -y-0, textureOffset.ax, textureOffset.ay,      0,  1,  0,
                                    x + 1,  z+1,  -y-0, textureOffset.bx, textureOffset.ay,      0,  1,  0,
                                    x + 1,  z+1,  -y-1, textureOffset.bx, textureOffset.by,      0,  1,  0,

                                    x + 0,  z+1,  -y-0, textureOffset.ax, textureOffset.ay,      0,  1,  0,
                                    x + 1,  z+1,  -y-1, textureOffset.bx, textureOffset.by,      0,  1,  0,
                                    x + 0,  z+1,  -y-1, textureOffset.ax, textureOffset.by,      0,  1,  0,
                                );
                            }

                            // Bottom
                            if (z == 0 || !blockTypes[chunk.data[posOffset(x,y,z-1)]].block) {
                                calcTextureOffsets(blockTypeInfo.image[5], textureOffset);
                                meshData.push(
                                    x + 0,  z+0,  -y-0, textureOffset.ax, textureOffset.ay,      0, -1,  0,
                                    x + 1,  z+0,  -y-1, textureOffset.bx, textureOffset.by,      0, -1,  0,
                                    x + 1,  z+0,  -y-0, textureOffset.bx, textureOffset.ay,      0, -1,  0,

                                    x + 0,  z+0,  -y-0, textureOffset.ax, textureOffset.ay,      0, -1,  0,
                                    x + 0,  z+0,  -y-1, textureOffset.ax, textureOffset.by,      0, -1,  0,
                                    x + 1,  z+0,  -y-1, textureOffset.bx, textureOffset.by,      0, -1,  0,
                                )
                            }

                            // Front
                            if ((y == 15 && !blockTypes[frontChunk.data[posOffset(x,0,z)]].block) || (y < 15 && !blockTypes[chunk.data[posOffset(x,y+1,z)]].block)) {
                                calcTextureOffsets(blockTypeInfo.image[1], textureOffset);
                                meshData.push(
                                    x + 0,  z+0,  -y-1, textureOffset.ax, textureOffset.by,      0,  0,  1,
                                    x + 1,  z+1,  -y-1, textureOffset.bx, textureOffset.ay,      0,  0,  1,
                                    x + 1,  z+0,  -y-1, textureOffset.bx, textureOffset.by,      0,  0,  1,

                                    x + 0,  z+0,  -y-1, textureOffset.ax, textureOffset.by,      0,  0,  1,
                                    x + 0,  z+1,  -y-1, textureOffset.ax, textureOffset.ay,      0,  0,  1,
                                    x + 1,  z+1,  -y-1, textureOffset.bx, textureOffset.ay,      0,  0,  1,
                                );
                            }

                            // Back
                            if ((y == 0 && !blockTypes[backChunk.data[posOffset(x,15,z)]].block) || (y > 0 && !blockTypes[chunk.data[posOffset(x,y-1,z)]].block)) {
                                calcTextureOffsets(blockTypeInfo.image[2], textureOffset);
                                meshData.push(
                                    x + 0,  z+0,  -y-0, textureOffset.bx, textureOffset.by,      0,  0, -1,
                                    x + 1,  z+0,  -y-0, textureOffset.ax, textureOffset.by,      0,  0, -1,
                                    x + 1,  z+1,  -y-0, textureOffset.ax, textureOffset.ay,      0,  0, -1,

                                    x + 0,  z+0,  -y-0, textureOffset.bx, textureOffset.by,      0,  0, -1,
                                    x + 1,  z+1,  -y-0, textureOffset.ax, textureOffset.ay,      0,  0, -1,
                                    x + 0,  z+1,  -y-0, textureOffset.bx, textureOffset.ay,      0,  0, -1,
                                );
                            }

                            // Left
                            if ((x == 0 && !blockTypes[leftChunk.data[posOffset(15,y,z)]].block) || (x > 0 && !blockTypes[chunk.data[posOffset(x-1,y,z)]].block)) {
                                calcTextureOffsets(blockTypeInfo.image[3], textureOffset);
                                meshData.push(
                                    x + 0,  z+0,  -y-1, textureOffset.bx, textureOffset.by,     -1,  0,  0,
                                    x + 0,  z+0,  -y-0, textureOffset.ax, textureOffset.by,     -1,  0,  0,
                                    x + 0,  z+1,  -y-1, textureOffset.bx, textureOffset.ay,     -1,  0,  0,

                                    x + 0,  z+0,  -y-0, textureOffset.ax, textureOffset.by,     -1,  0,  0,
                                    x + 0,  z+1,  -y-0, textureOffset.ax, textureOffset.ay,     -1,  0,  0,
                                    x + 0,  z+1,  -y-1, textureOffset.bx, textureOffset.ay,     -1,  0,  0,
                                );
                            }

                            // Right
                            if ((x == 15 && !blockTypes[rightChunk.data[posOffset(0,y,z)]].block) || (x < 15 && !blockTypes[chunk.data[posOffset(x+1,y,z)]].block)) {
                                calcTextureOffsets(blockTypeInfo.image[4], textureOffset);
                                meshData.push(
                                    x + 1,  z+0,  -y-1, textureOffset.ax, textureOffset.by,      1,  0,  0,
                                    x + 1,  z+1,  -y-1, textureOffset.ax, textureOffset.ay,      1,  0,  0,
                                    x + 1,  z+0,  -y-0, textureOffset.bx, textureOffset.by,      1,  0,  0,

                                    x + 1,  z+0,  -y-0, textureOffset.bx, textureOffset.by,      1,  0,  0,
                                    x + 1,  z+1,  -y-1, textureOffset.ax, textureOffset.ay,      1,  0,  0,
                                    x + 1,  z+1,  -y-0, textureOffset.bx, textureOffset.ay,      1,  0,  0,
                                );
                            }
                        }
                    }
                }
            }

            for (var z=0;z<128;z++) {
                for (var y=0;y<16;y++) {
                    for (var x=0;x<16;x++) {
                    
                        const blockTypeInfo = blockTypes[chunk.data[posOffset(x,y,z)]];

                        if (blockTypeInfo.liquid) {
                            let liquidAbove = z < 127 && blockTypes[chunk.data[posOffset(x,y,z+1)]].liquid;

                            if (!liquidAbove) {

                                calcTextureOffsets(blockTypeInfo.image[0], textureOffset);
                                meshData.push(
                                    x + 0,  z+0.9,  -y-0, textureOffset.ax, textureOffset.ay,      0,  1,  0,
                                    x + 1,  z+0.9,  -y-0, textureOffset.bx, textureOffset.ay,      0,  1,  0,
                                    x + 1,  z+0.9,  -y-1, textureOffset.bx, textureOffset.by,      0,  1,  0,

                                    x + 0,  z+0.9,  -y-0, textureOffset.ax, textureOffset.ay,      0,  1,  0,
                                    x + 1,  z+0.9,  -y-1, textureOffset.bx, textureOffset.by,      0,  1,  0,
                                    x + 0,  z+0.9,  -y-1, textureOffset.ax, textureOffset.by,      0,  1,  0,
                                );

                                meshData.push(
                                    x + 0,  z+0.9,  -y-0, textureOffset.ax, textureOffset.ay,      0, -1,  0,
                                    x + 1,  z+0.9,  -y-1, textureOffset.bx, textureOffset.by,      0, -1,  0,
                                    x + 1,  z+0.9,  -y-0, textureOffset.bx, textureOffset.ay,      0, -1,  0,

                                    x + 0,  z+0.9,  -y-0, textureOffset.ax, textureOffset.ay,      0, -1,  0,
                                    x + 0,  z+0.9,  -y-1, textureOffset.ax, textureOffset.by,      0, -1,  0,
                                    x + 1,  z+0.9,  -y-1, textureOffset.bx, textureOffset.by,      0, -1,  0,
                                )
                            }
                        }

                    }
                }
            }



            var buffer1Data = new Float32Array(meshData);


            
            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, buffer1Data, gl.DYNAMIC_DRAW);

            chunk.elementCount = buffer1Data.length / 8
            chunk.dirty = false;

            return true;
        }



        var buffer2Data = new Float32Array([
            -0.01, -0.01,  0.01,
             1.01, -0.01,  0.01,
            -0.01,  1.01,  0.01,
             1.01,  1.01,  0.01,
            
            -0.01, -0.01, -1.01,
             1.01, -0.01, -1.01,
            -0.01,  1.01, -1.01,
             1.01,  1.01, -1.01 
        ]);


        var buffer3Data = new Uint8Array([
            4,6,5,
            5,6,7,
            5,7,1,
            1,7,3,
            1,3,0,
            0,3,2,
            0,2,4,
            4,2,6,
            6,2,7,
            7,2,3,
            0,4,1,
            1,4,5,

            4,5 ,5,1, 1,0, 0,4, 6,7, 7,3, 3,2, 2,6, 
            4,6, 5,7, 1,3, 0,2
        ]);


        blockTypes.forEach(blockType => {
            if (!blockType.block && !blockType.liquid) return;

            let textureOffset = [{}, {}, {}, {}, {}, {}];
            for (let i=0; i<6; i++) calcTextureOffsets(blockType.image[i], textureOffset[i]);

            var vertexData = new Float32Array([
                -0.05, -0.05,  0.05,    textureOffset[1].ax, textureOffset[1].by,    0, 0, 1,
                 0.05, -0.05,  0.05,    textureOffset[1].bx, textureOffset[1].by,    0, 0, 1,
                 0.05,  0.05,  0.05,    textureOffset[1].bx, textureOffset[1].ay,    0, 0, 1,
                -0.05,  0.05,  0.05,    textureOffset[1].ax, textureOffset[1].ay,    0, 0, 1,

                 0.05, -0.05,  0.05,    textureOffset[4].ax, textureOffset[4].by,    1, 0, 0,
                 0.05, -0.05, -0.05,    textureOffset[4].bx, textureOffset[4].by,    1, 0, 0,
                 0.05,  0.05, -0.05,    textureOffset[4].bx, textureOffset[4].ay,    1, 0, 0,
                 0.05,  0.05,  0.05,    textureOffset[4].ax, textureOffset[4].ay,    1, 0, 0,

                 0.05, -0.05, -0.05,    textureOffset[2].ax, textureOffset[2].by,    0, 0,-1,
                -0.05, -0.05, -0.05,    textureOffset[2].bx, textureOffset[2].by,    0, 0,-1,
                -0.05,  0.05, -0.05,    textureOffset[2].bx, textureOffset[2].ay,    0, 0,-1,
                 0.05,  0.05, -0.05,    textureOffset[2].ax, textureOffset[2].ay,    0, 0,-1,

                -0.05, -0.05, -0.05,    textureOffset[3].ax, textureOffset[3].by,   -1, 0, 0,
                -0.05, -0.05,  0.05,    textureOffset[3].bx, textureOffset[3].by,   -1, 0, 0,
                -0.05,  0.05,  0.05,    textureOffset[3].bx, textureOffset[3].ay,   -1, 0, 0,
                -0.05,  0.05, -0.05,    textureOffset[3].ax, textureOffset[3].ay,   -1, 0, 0,

                -0.05,  0.05,  0.05,    textureOffset[0].ax, textureOffset[0].by,    0, 1, 0,
                 0.05,  0.05,  0.05,    textureOffset[0].bx, textureOffset[0].by,    0, 1, 0,
                 0.05,  0.05, -0.05,    textureOffset[0].bx, textureOffset[0].ay,    0, 1, 0,
                -0.05,  0.05, -0.05,    textureOffset[0].ax, textureOffset[0].ay,    0, 1, 0,

                -0.05, -0.05, -0.05,    textureOffset[5].ax, textureOffset[5].by,    0,-1, 0,
                 0.05, -0.05, -0.05,    textureOffset[5].bx, textureOffset[5].by,    0,-1, 0,
                 0.05, -0.05,  0.05,    textureOffset[5].bx, textureOffset[5].ay,    0,-1, 0,
                -0.05, -0.05,  0.05,    textureOffset[5].ax, textureOffset[5].ay,    0,-1, 0,
            ]);

            var indexData = new Uint8Array([
                 0,  1,  3,    1,  2,  3,
                 4,  5,  7,    5,  6,  7,
                 8,  9, 11,    9, 10, 11,
                12, 13, 15,   13, 14, 15,
                16, 17, 19,   17, 18, 19,
                20, 21, 23,   21, 22, 23
            ]);

            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);

            blockType.mesh = {
                vertexBuffer: vertexBuffer,
                indexBuffer: indexBuffer,
                elementCount: 6*6
            };
        });

        var steveData = new Float32Array([
             0.4,  1.2,  0.2,    0.285714,  0.625,    0,  0,  1,
             0,  0,  0.2,    0.214286,  1,    0,  0,  1,
             0.4,  0,  0.2,    0.285714,  1,    0,  0,  1,
             0,  1.2,  0.2,    0.214286,  0.625,   -1,  0,  0,
             0,  0, -0.2,    0.142857,  1,   -1,  0,  0,
             0,  0,  0.2,    0.214286,  1,   -1,  0,  0,
             0,  1.2, -0.2,    0.142857,  0.625,    0,  0, -1,
             0.4,  0, -0.2,    0.071429,  1,    0,  0, -1,
             0,  0, -0.2,    0.142857,  1,    0,  0, -1,
             0.4,  1.2, -0.2,    0.071428,  0.625,    1,  0,  0,
             0.4,  0,  0.2,    0,  1,    1,  0,  0,
             0.4,  0, -0.2,    0.071429,  1,    1,  0,  0,
             0,  0, -0.2,    0.214286,  0.625,    0, -1,  0,
             0.4,  0,  0.2,    0.142857,  0.5,    0, -1,  0,
             0,  0,  0.2,    0.142857,  0.625,    0, -1,  0,
             0,  1.2,  0.2,    0.142857,  0.625,    0,  1,  0,
             0.4,  1.2, -0.2,    0.071429,  0.5,    0,  1,  0,
             0,  1.2, -0.2,    0.071429,  0.625,    0,  1,  0,
             0.4,  1.2,  0.2,    0.285714,  0.625,    0,  0,  1,
             0,  1.2,  0.2,    0.214286,  0.625,    0,  0,  1,
             0,  0,  0.2,    0.214286,  1,    0,  0,  1,
             0,  1.2,  0.2,    0.214286,  0.625,   -1,  0,  0,
             0,  1.2, -0.2,    0.142857,  0.625,   -1,  0,  0,
             0,  0, -0.2,    0.142857,  1,   -1,  0,  0,
             0,  1.2, -0.2,    0.142857,  0.625,    0,  0, -1,
             0.4,  1.2, -0.2,    0.071428,  0.625,    0,  0, -1,
             0.4,  0, -0.2,    0.071429,  1,    0,  0, -1,
             0.4,  1.2, -0.2,    0.071428,  0.625,    1,  0,  0,
             0.4,  1.2,  0.2,    0,  0.625,    1,  0,  0,
             0.4,  0,  0.2,    0,  1,    1,  0,  0,
             0,  0, -0.2,    0.214286,  0.625,    0, -1,  0,
             0.4,  0, -0.2,    0.214286,  0.5,    0, -1,  0,
             0.4,  0,  0.2,    0.142857,  0.5,    0, -1,  0,
             0,  1.2,  0.2,    0.142857,  0.625,    0,  1,  0,
             0.4,  1.2,  0.2,    0.142857,  0.5,    0,  1,  0,
             0.4,  1.2, -0.2,    0.071429,  0.5,    0,  1,  0,
             0.8,  2.4,  0.2,    0.714286,  0.625,    0,  0,  1,
             0.4,  1.2,  0.2,    0.785714,  1,    0,  0,  1,
             0.8,  1.2,  0.2,    0.714286,  1,    0,  0,  1,
             0.4,  2.4,  0.2,    0.928571,  0.625,   -1,  0,  0,
             0.4,  1.2, -0.2,    1,  1,   -1,  0,  0,
             0.4,  1.2,  0.2,    0.928571,  1,   -1,  0,  0,
             0.4,  2.4, -0.2,    0.928571,  0.625,    0,  0, -1,
             0.8,  1.2, -0.2,    0.857143,  1,    0,  0, -1,
             0.4,  1.2, -0.2,    0.928571,  1,    0,  0, -1,
             0.8,  2.4, -0.2,    0.785714,  0.625,    1,  0,  0,
             0.8,  1.2,  0.2,    0.857143,  1,    1,  0,  0,
             0.8,  1.2, -0.2,    0.785714,  1,    1,  0,  0,
             0.4,  1.2, -0.2,    0.928571,  0.625,    0, -1,  0,
             0.8,  1.2,  0.2,    0.857143,  0.5,    0, -1,  0,
             0.4,  1.2,  0.2,    0.857143,  0.625,    0, -1,  0,
             0.4,  2.4,  0.2,    0.785714,  0.5,    0,  1,  0,
             0.8,  2.4, -0.2,    0.857143,  0.625,    0,  1,  0,
             0.4,  2.4, -0.2,    0.857143,  0.5,    0,  1,  0,
             0.8,  2.4,  0.2,    0.714286,  0.625,    0,  0,  1,
             0.4,  2.4,  0.2,    0.785714,  0.625,    0,  0,  1,
             0.4,  1.2,  0.2,    0.785714,  1,    0,  0,  1,
             0.4,  2.4,  0.2,    0.928571,  0.625,   -1,  0,  0,
             0.4,  2.4, -0.2,    1,  0.625,   -1,  0,  0,
             0.4,  1.2, -0.2,    1,  1,   -1,  0,  0,
             0.4,  2.4, -0.2,    0.928571,  0.625,    0,  0, -1,
             0.8,  2.4, -0.2,    0.857143,  0.625,    0,  0, -1,
             0.8,  1.2, -0.2,    0.857143,  1,    0,  0, -1,
             0.8,  2.4, -0.2,    0.785714,  0.625,    1,  0,  0,
             0.8,  2.4,  0.2,    0.857143,  0.625,    1,  0,  0,
             0.8,  1.2,  0.2,    0.857143,  1,    1,  0,  0,
             0.4,  1.2, -0.2,    0.928571,  0.625,    0, -1,  0,
             0.8,  1.2, -0.2,    0.928571,  0.5,    0, -1,  0,
             0.8,  1.2,  0.2,    0.857143,  0.5,    0, -1,  0,
             0.4,  2.4,  0.2,    0.785714,  0.5,    0,  1,  0,
             0.8,  2.4,  0.2,    0.785714,  0.625,    0,  1,  0,
             0.8,  2.4, -0.2,    0.857143,  0.625,    0,  1,  0,
            -0.4,  2.4,  0.2,    0.714286,  0.625,    0,  0,  1,
            -0.8,  1.2,  0.2,    0.785714,  1,    0,  0,  1,
            -0.4,  1.2,  0.2,    0.714286,  1,    0,  0,  1,
            -0.8,  2.4,  0.2,    0.857143,  0.625,   -1,  0,  0,
            -0.8,  1.2, -0.2,    0.928571,  1,   -1,  0,  0,
            -0.8,  1.2,  0.2,    0.857143,  1,   -1,  0,  0,
            -0.8,  2.4, -0.2,    0.928572,  0.625,    0,  0, -1,
            -0.4,  1.2, -0.2,    1,  1,    0,  0, -1,
            -0.8,  1.2, -0.2,    0.928571,  1,    0,  0, -1,
            -0.4,  2.4, -0.2,    0.785714,  0.625,    1,  0,  0,
            -0.4,  1.2,  0.2,    0.857143,  1,    1,  0,  0,
            -0.4,  1.2, -0.2,    0.785714,  1,    1,  0,  0,
            -0.8,  1.2, -0.2,    0.928571,  0.625,    0, -1,  0,
            -0.4,  1.2,  0.2,    0.857143,  0.5,    0, -1,  0,
            -0.8,  1.2,  0.2,    0.857143,  0.625,    0, -1,  0,
            -0.8,  2.4,  0.2,    0.857143,  0.625,    0,  1,  0,
            -0.4,  2.4, -0.2,    0.785714,  0.5,    0,  1,  0,
            -0.8,  2.4, -0.2,    0.785714,  0.625,    0,  1,  0,
            -0.4,  2.4,  0.2,    0.714286,  0.625,    0,  0,  1,
            -0.8,  2.4,  0.2,    0.785714,  0.625,    0,  0,  1,
            -0.8,  1.2,  0.2,    0.785714,  1,    0,  0,  1,
            -0.8,  2.4,  0.2,    0.857143,  0.625,   -1,  0,  0,
            -0.8,  2.4, -0.2,    0.928572,  0.625,   -1,  0,  0,
            -0.8,  1.2, -0.2,    0.928571,  1,   -1,  0,  0,
            -0.8,  2.4, -0.2,    0.928572,  0.625,    0,  0, -1,
            -0.4,  2.4, -0.2,    1,  0.625,    0,  0, -1,
            -0.4,  1.2, -0.2,    1,  1,    0,  0, -1,
            -0.4,  2.4, -0.2,    0.785714,  0.625,    1,  0,  0,
            -0.4,  2.4,  0.2,    0.857143,  0.625,    1,  0,  0,
            -0.4,  1.2,  0.2,    0.857143,  1,    1,  0,  0,
            -0.8,  1.2, -0.2,    0.928571,  0.625,    0, -1,  0,
            -0.4,  1.2, -0.2,    0.928571,  0.5,    0, -1,  0,
            -0.4,  1.2,  0.2,    0.857143,  0.5,    0, -1,  0,
            -0.8,  2.4,  0.2,    0.857143,  0.625,    0,  1,  0,
            -0.4,  2.4,  0.2,    0.857143,  0.5,    0,  1,  0,
            -0.4,  2.4, -0.2,    0.785714,  0.5,    0,  1,  0,
             0.4,  3.2,  0.4,    0.571429,  0.25,    0,  0,  1,
            -0.4,  2.4,  0.4,    0.428571,  0.5,    0,  0,  1,
             0.4,  2.4,  0.4,    0.571429,  0.5,    0,  0,  1,
            -0.4,  3.2,  0.4,    0.428571,  0.25,   -1,  0,  0,
            -0.4,  2.4, -0.4,    0.285714,  0.5,   -1,  0,  0,
            -0.4,  2.4,  0.4,    0.428571,  0.5,   -1,  0,  0,
            -0.4,  3.2, -0.4,    0.285714,  0.25,    0,  0, -1,
             0.4,  2.4, -0.4,    0.142857,  0.5,    0,  0, -1,
            -0.4,  2.4, -0.4,    0.285714,  0.5,    0,  0, -1,
             0.4,  3.2, -0.4,    0.142857,  0.25,    1,  0,  0,
             0.4,  2.4,  0.4,    0,  0.5,    1,  0,  0,
             0.4,  2.4, -0.4,    0.142857,  0.5,    1,  0,  0,
            -0.4,  2.4, -0.4,    0.428571,  0.25,    0, -1,  0,
             0.4,  2.4,  0.4,    0.285714,  0,    0, -1,  0,
            -0.4,  2.4,  0.4,    0.285714,  0.25,    0, -1,  0,
            -0.4,  3.2,  0.4,    0.285714,  0,    0,  1,  0,
             0.4,  3.2, -0.4,    0.142857,  0.25,    0,  1,  0,
            -0.4,  3.2, -0.4,    0.285714,  0.25,    0,  1,  0,
             0.4,  3.2,  0.4,    0.571429,  0.25,    0,  0,  1,
            -0.4,  3.2,  0.4,    0.428571,  0.25,    0,  0,  1,
            -0.4,  2.4,  0.4,    0.428571,  0.5,    0,  0,  1,
            -0.4,  3.2,  0.4,    0.428571,  0.25,   -1,  0,  0,
            -0.4,  3.2, -0.4,    0.285714,  0.25,   -1,  0,  0,
            -0.4,  2.4, -0.4,    0.285714,  0.5,   -1,  0,  0,
            -0.4,  3.2, -0.4,    0.285714,  0.25,    0,  0, -1,
             0.4,  3.2, -0.4,    0.142857,  0.25,    0,  0, -1,
             0.4,  2.4, -0.4,    0.142857,  0.5,    0,  0, -1,
             0.4,  3.2, -0.4,    0.142857,  0.25,    1,  0,  0,
             0.4,  3.2,  0.4,    0,  0.25,    1,  0,  0,
             0.4,  2.4,  0.4,    0,  0.5,    1,  0,  0,
            -0.4,  2.4, -0.4,    0.428571,  0.25,    0, -1,  0,
             0.4,  2.4, -0.4,    0.428571,  0,    0, -1,  0,
             0.4,  2.4,  0.4,    0.285714,  0,    0, -1,  0,
            -0.4,  3.2,  0.4,    0.285714,  0,    0,  1,  0,
             0.4,  3.2,  0.4,    0.142857,  0,    0,  1,  0,
             0.4,  3.2, -0.4,    0.142857,  0.25,    0,  1,  0,
             0.4,  2.4,  0.2,    0.714286,  0.625,    0,  0,  1,
            -0.4,  1.2,  0.2,    0.571429,  1,    0,  0,  1,
             0.4,  1.2,  0.2,    0.714286,  1,    0,  0,  1,
            -0.4,  2.4,  0.2,    0.571429,  0.625,   -1,  0,  0,
            -0.4,  1.2, -0.2,    0.5,  1,   -1,  0,  0,
            -0.4,  1.2,  0.2,    0.571429,  1,   -1,  0,  0,
            -0.4,  2.4, -0.2,    0.5,  0.625,    0,  0, -1,
             0.4,  1.2, -0.2,    0.357143,  1,    0,  0, -1,
            -0.4,  1.2, -0.2,    0.5,  1,    0,  0, -1,
             0.4,  2.4, -0.2,    0.357143,  0.625,    1,  0,  0,
             0.4,  1.2,  0.2,    0.285714,  1,    1,  0,  0,
             0.4,  1.2, -0.2,    0.357143,  1,    1,  0,  0,
            -0.4,  1.2, -0.2,    0.642857,  0.5,    0, -1,  0,
             0.4,  1.2,  0.2,    0.5,  0.625,    0, -1,  0,
            -0.4,  1.2,  0.2,    0.5,  0.5,    0, -1,  0,
            -0.4,  2.4,  0.2,    0.5,  0.5,    0,  1,  0,
             0.4,  2.4, -0.2,    0.357143,  0.625,    0,  1,  0,
            -0.4,  2.4, -0.2,    0.5,  0.625,    0,  1,  0,
             0.4,  2.4,  0.2,    0.714286,  0.625,    0,  0,  1,
            -0.4,  2.4,  0.2,    0.571429,  0.625,    0,  0,  1,
            -0.4,  1.2,  0.2,    0.571429,  1,    0,  0,  1,
            -0.4,  2.4,  0.2,    0.571429,  0.625,   -1,  0,  0,
            -0.4,  2.4, -0.2,    0.5,  0.625,   -1,  0,  0,
            -0.4,  1.2, -0.2,    0.5,  1,   -1,  0,  0,
            -0.4,  2.4, -0.2,    0.5,  0.625,    0,  0, -1,
             0.4,  2.4, -0.2,    0.357143,  0.625,    0,  0, -1,
             0.4,  1.2, -0.2,    0.357143,  1,    0,  0, -1,
             0.4,  2.4, -0.2,    0.357143,  0.625,    1,  0,  0,
             0.4,  2.4,  0.2,    0.285714,  0.625,    1,  0,  0,
             0.4,  1.2,  0.2,    0.285714,  1,    1,  0,  0,
            -0.4,  1.2, -0.2,    0.642857,  0.5,    0, -1,  0,
             0.4,  1.2, -0.2,    0.642857,  0.625,    0, -1,  0,
             0.4,  1.2,  0.2,    0.5,  0.625,    0, -1,  0,
            -0.4,  2.4,  0.2,    0.5,  0.5,    0,  1,  0,
             0.4,  2.4,  0.2,    0.357143,  0.5,    0,  1,  0,
             0.4,  2.4, -0.2,    0.357143,  0.625,    0,  1,  0,
             0,  1.2,  0.2,    0.285714,  0.625,    0,  0,  1,
            -0.4,  0,  0.2,    0.214286,  1,    0,  0,  1,
             0,  0,  0.2,    0.285714,  1,    0,  0,  1,
            -0.4,  1.2,  0.2,    0.214286,  0.625,   -1,  0,  0,
            -0.4,  0, -0.2,    0.142857,  1,   -1,  0,  0,
            -0.4,  0,  0.2,    0.214286,  1,   -1,  0,  0,
            -0.4,  1.2, -0.2,    0.142857,  0.625,    0,  0, -1,
             0,  0, -0.2,    0.071429,  1,    0,  0, -1,
            -0.4,  0, -0.2,    0.142857,  1,    0,  0, -1,
             0,  1.2, -0.2,    0.071428,  0.625,    1,  0,  0,
             0,  0,  0.2,    0,  1,    1,  0,  0,
             0,  0, -0.2,    0.071429,  1,    1,  0,  0,
            -0.4,  0, -0.2,    0.214286,  0.625,    0, -1,  0,
             0,  0,  0.2,    0.142857,  0.5,    0, -1,  0,
            -0.4,  0,  0.2,    0.142857,  0.625,    0, -1,  0,
            -0.4,  1.2,  0.2,    0.142857,  0.625,    0,  1,  0,
             0,  1.2, -0.2,    0.071429,  0.5,    0,  1,  0,
            -0.4,  1.2, -0.2,    0.071429,  0.625,    0,  1,  0,
             0,  1.2,  0.2,    0.285714,  0.625,    0,  0,  1,
            -0.4,  1.2,  0.2,    0.214286,  0.625,    0,  0,  1,
            -0.4,  0,  0.2,    0.214286,  1,    0,  0,  1,
            -0.4,  1.2,  0.2,    0.214286,  0.625,   -1,  0,  0,
            -0.4,  1.2, -0.2,    0.142857,  0.625,   -1,  0,  0,
            -0.4,  0, -0.2,    0.142857,  1,   -1,  0,  0,
            -0.4,  1.2, -0.2,    0.142857,  0.625,    0,  0, -1,
             0,  1.2, -0.2,    0.071428,  0.625,    0,  0, -1,
             0,  0, -0.2,    0.071429,  1,    0,  0, -1,
             0,  1.2, -0.2,    0.071428,  0.625,    1,  0,  0,
             0,  1.2,  0.2,    0,  0.625,    1,  0,  0,
             0,  0,  0.2,    0,  1,    1,  0,  0,
            -0.4,  0, -0.2,    0.214286,  0.625,    0, -1,  0,
             0,  0, -0.2,    0.214286,  0.5,    0, -1,  0,
             0,  0,  0.2,    0.142857,  0.5,    0, -1,  0,
            -0.4,  1.2,  0.2,    0.142857,  0.625,    0,  1,  0,
             0,  1.2,  0.2,    0.142857,  0.5,    0,  1,  0,
             0,  1.2, -0.2,    0.071429,  0.5,    0,  1,  0,
        ]);

        var steveBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, steveBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, steveData, gl.STATIC_DRAW);


        const steveMesh = {
            vertexBuffer: steveBuffer,
            indexBuffer: null,
            elementCount: steveData.length / 8
        }


        var portalBufferData = new Float32Array([
             28.5, 58.0, -35.0, 
             28.5, 61.0, -35.0,
             28.5, 58.0, -37.0, 

             28.5, 58.0, -37.0,
             28.5, 61.0, -35.0,
             28.5, 61.0, -37.0, 
        ]);

        var frustumBuffer = gl.createBuffer();
        var renderFrustum = false;

        var portalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, portalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, portalBufferData, gl.STATIC_DRAW);

        var buffer2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
        gl.bufferData(gl.ARRAY_BUFFER, buffer2Data, gl.STATIC_DRAW);

        var buffer3 = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer3);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffer3Data, gl.STATIC_DRAW);



        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);

        // some global settings
        var renderDistance = 10;
        var fov = 60;


        var time = 0.0;
        

        var topView = false;



        const walkSpeed = 0.15;
        const turnSpeed = 0.05;


        var keys = {};
        var newKeys = {};

        

        // Find start height.
        var initialChunk = world.findChunk(0,0);
        for (var z=127;z>0;z--) {
            if (initialChunk.data[posOffset(0, 0, z)] != 0) break;

            activePlayer.pos.z = z + 3;
        }


        window.onkeydown = e => {
            const keyCode = e.key.toLowerCase();
            if (!keys[keyCode]) newKeys[keyCode] = true;
            keys[keyCode] = true;
        }
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;

        
        canvas.onmousemove = e => {
            if (e.buttons || document.pointerLockElement) {
                activePlayer.rotation.yaw -= e.movementX * 0.005;
                activePlayer.rotation.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, activePlayer.rotation.pitch - e.movementY * 0.005));
            }
        }

        var clickLeft = false;
        var clickRight = false;

        canvas.onmousedown = e => {
            
            if (!document.pointerLockElement) {
                canvas.requestPointerLock();
                document.getElementById("menu").style.display = "none";
                return;
            }

            if (e.button == 0) clickLeft = true;
            if (e.button == 2) clickRight = true;
        }

        canvas.onwheel = e => {
            if (e.deltaY <= -1) { activePlayer.activeItem = Math.max(0, activePlayer.activeItem - 1); setActiveItem(activePlayer.activeItem); }
            if (e.deltaY >=  1) { activePlayer.activeItem = Math.min(7, activePlayer.activeItem + 1); setActiveItem(activePlayer.activeItem); }
        }

        function updateAll(delta) {
            for (const entity of entities) {
                if (entity.type == ENTITY_TYPE_ITEM) {
                    entity.rotation.yaw -= delta;
                }
            };

            for (const entity of entities) {
                if (!entity.age) entity.age = 0;
                entity.age += delta;

                const oldZ = entity.pos.z;

                entity.velocity.x += entity.acceleration.x * delta;
                entity.velocity.y += entity.acceleration.y * delta;
                entity.velocity.z += entity.acceleration.z * delta;

                entity.velocity.z = Math.max(entity.velocity.z, -50); // TODO: we fall trough the world at about -60. Probably FPS related

                entity.pos.x += entity.velocity.x * delta;
                entity.pos.y += entity.velocity.y * delta;
                entity.pos.z += entity.velocity.z * delta;

                // entity on world collision
                {
                    const chunkX = Math.floor(entity.pos.x/16);
                    const chunkY = Math.floor(entity.pos.y/16);
                    const currentChunk = world.findChunk(chunkX, chunkY);
                    if (currentChunk) {
                        const chunkOffsetX = Math.floor(entity.pos.x - chunkX * 16);
                        const chunkOffsetY = Math.floor(entity.pos.y - chunkY * 16);

                        const lowZ = Math.floor(entity.pos.z);
                        const highZ = Math.floor(entity.pos.z + entity.height);

                        for (var z=lowZ; z<=highZ; z++) {
                            if (z < 0 || z >= 128) continue;

                            const dataOffset = posOffset(chunkOffsetX, chunkOffsetY, z);
                            const blockType = currentChunk.data[dataOffset];

                            if (blockTypes[blockType].block) {
                                const blockBottom = z;
                                const blockTop = z + 1;

                                if (entity.pos.z < blockTop) {
                                    if (oldZ + entity.height < blockBottom) {
                                        entity.pos.z = blockBottom - entity.height;
                                    } else {
                                        entity.pos.z = blockTop;
                                        entity.standing = true;                                        
                                    }

                                    entity.velocity.x = 0;
                                    entity.velocity.y = 0;
                                    entity.velocity.z = 0;
                                }
                            }
                        }
                    }
                }

                // Absolute bottom safeguard. TODO: just die and respawn here...
                if (entity.pos.z < -20) entity.pos.z = -20;
            };

            // some simple entity on entity collection
            for (const entity of entities) {
                if (entity.age < 1.0) continue;
                if (entity.deleted) continue;

                for (const otherEntity of entities) {
                    if (otherEntity.age < 1.0) continue;
                    if (otherEntity.deleted) continue;
                    if (entity == otherEntity) continue;

                    // calculate the XY distance between the entities
                    const planeDistX = otherEntity.pos.x - entity.pos.x;
                    const planeDistY = otherEntity.pos.y - entity.pos.y;
                    const dist = Math.hypot(planeDistX, planeDistY);

                    // calculate on what XY distance we consider touch
                    const allowDist = entity.radius + otherEntity.radius;

                    if (allowDist >= dist) {
                        if (entity.type == ENTITY_TYPE_PLAYER && otherEntity.type == ENTITY_TYPE_ITEM) {

                            let shouldUpdateUI = false;

                            // 1st try to append to existing stack
                            for (let index in entity.inventory) {
                                let inventoryItem = entity.inventory[index];
                                if (inventoryItem && inventoryItem.blockType == otherEntity.blockType) {

                                    const max = 64 - inventoryItem.blockCount;
                                    const toTake = Math.min(max, otherEntity.blockCount);

                                    if (toTake >= 1) {

                                        inventoryItem.blockCount += toTake;
                                        otherEntity.blockCount -= toTake;
                                        shouldUpdateUI = true;
                                    }
                                }
                            }

                            // try to add the rest to empty slots
                            for (let index in entity.inventory) {
                                if (!entity.inventory[index]) {
                                    const toTake = Math.min(64, otherEntity.blockCount);

                                    if (toTake >= 1) {
                                        entity.inventory[index] = {blockType: otherEntity.blockType, blockCount: toTake};

                                        otherEntity.blockCount -= toTake;
                                        shouldUpdateUI = true;
                                    }
                                }
                            }

                            if (otherEntity.blockCount <= 0) otherEntity.deleted = true;

                            if (shouldUpdateUI) updateUI();
                        }

                        if (entity.type == ENTITY_TYPE_ITEM && otherEntity.type == ENTITY_TYPE_ITEM) {
                            if (entity.blockType == otherEntity.blockType) {
                                entity.blockCount += otherEntity.blockCount;
                                otherEntity.deleted = true;
                            }
                        }
                    }
                }
            }

            for (const entity of entities) {
                if (entity.type == ENTITY_TYPE_ITEM) {
                    if (entity.age > 300) entity.deleted = true;
                }
            }

            entities = entities.filter(entity => !entity.deleted)
        }

        function traceRay(startX, startY, startZ, dirX, dirY, dirZ, steps) {
            const deltaDistX = Math.abs(1/dirX);
            const deltaDistY = Math.abs(1/dirY);
            const deltaDistZ = Math.abs(1/dirZ);

            const deltaMapX = dirX < 0 ? -1 : 1;
            const deltaMapY = dirY < 0 ? -1 : 1;
            const deltaMapZ = dirZ < 0 ? -1 : 1;

            var mapX = Math.floor(startX);
            var mapY = Math.floor(startY);
            var mapZ = Math.floor(startZ);

            var sideDistX = ((dirX < 0) ? (startX - Math.floor(startX)) : (Math.floor(startX + 1.0) - startX)) * deltaDistX;
            var sideDistY = ((dirY < 0) ? (startY - Math.floor(startY)) : (Math.floor(startY + 1.0) - startY)) * deltaDistY;
            var sideDistZ = ((dirZ < 0) ? (startZ - Math.floor(startZ)) : (Math.floor(startZ + 1.0) - startZ)) * deltaDistZ;

            var cursorX = 0;
            var cursorY = 0;
            var cursorZ = 0;

            var prevCursorX = 0;
            var prevCursorY = 0;
            var prevCursorZ = 0;


            for (var i=0; i<steps; i++) {
                if (sideDistX <= sideDistY && sideDistX <= sideDistZ) {
                    //if (sideDistX > lineLength) break;

                    //ctx.fillStyle = "#0000ff";
                    //circle(add(pos, mul(dirVec, sideDistX)));

                    sideDistX += deltaDistX;
                    mapX += deltaMapX;

                } else if (sideDistY <= sideDistX && sideDistY <= sideDistZ) {
                    //if (sideDistY > lineLength) break;

                    //ctx.fillStyle = "#0000ff";
                    //circle(add(pos, mul(dirVec, sideDistY)));

                    sideDistY += deltaDistY;
                    mapY += deltaMapY;
                } else {
                    sideDistZ += deltaDistZ;
                    mapZ += deltaMapZ;
                }
                

                let info = false;
                if (mapZ >= 0 && mapZ <= 127) {
                    const chunk = world.findChunk(Math.floor(mapX / 16), Math.floor(mapY / 16));
                    if (chunk) {
                        const chunkX = mapX - (Math.floor(mapX / 16) * 16);
                        const chunkY = mapY - (Math.floor(mapY / 16) * 16);
                        const chunkZ = mapZ;

                        info = blockTypes[chunk.data[posOffset(chunkX, chunkY, chunkZ)]].block;
                    }
                }

                if (info) {
                    cursorX = mapX;
                    cursorY = mapY;
                    cursorZ = mapZ;
                    break;
                }

                prevCursorX = mapX;
                prevCursorY = mapY;
                prevCursorZ = mapZ;
            }

            return {
                cursor: {
                    x: cursorX,
                    y: cursorY,
                    z: cursorZ
                },
                prevCursor: {
                    x: prevCursorX,
                    y: prevCursorY,
                    z: prevCursorZ
                }
            };
        }

        function test() {
            for (let x=0; x<10; x++)
                for (let y=0; y<10; y++)
                    for (let z=10; z<30; z++) {
                        const chunk = world.findChunk(Math.floor(x/16), Math.floor(y/16));
                        if (!chunk) continue;
                        const blockType = chunk.data[posOffset(x,y,z)];
                        console.log(blockType);
                    }
        }

        const XBOX_CONTROLLER_AXIS_LEFT_X = 0;
        const XBOX_CONTROLLER_AXIS_LEFT_Y = 1;
        const XBOX_CONTROLLER_AXIS_RIGHT_X = 2;
        const XBOX_CONTROLLER_AXIS_RIGHT_Y = 3;

        const XBOX_CONTROLLER_BUTTON_A = 0;
        const XBOX_CONTROLLER_BUTTON_B = 1;
        const XBOX_CONTROLLER_BUTTON_X = 2;
        const XBOX_CONTROLLER_BUTTON_Y = 3;
        const XBOX_CONTROLLER_BUTTON_LB = 4;
        const XBOX_CONTROLLER_BUTTON_RB = 5;
        const XBOX_CONTROLLER_BUTTON_LT = 6;
        const XBOX_CONTROLLER_BUTTON_RT = 7;
        const XBOX_CONTROLLER_BUTTON_VIEW = 8;
        const XBOX_CONTROLLER_BUTTON_MENU = 9;
        const XBOX_CONTROLLER_BUTTON_STICK_LEFT = 10;
        const XBOX_CONTROLLER_BUTTON_STICK_RIGHT = 11;
        const XBOX_CONTROLLER_BUTTON_UP = 12;
        const XBOX_CONTROLLER_BUTTON_DOWN = 13;
        const XBOX_CONTROLLER_BUTTON_LEFT = 14;
        const XBOX_CONTROLLER_BUTTON_RIGHT = 15;
        const XBOX_CONTROLLER_BUTTON_XBOX = 16;

        const OCULUS_TOUCH_ID_LEFT = "Oculus Touch (Left)";
        const OCULUS_TOUCH_ID_RIGHT = "Oculus Touch (Right)";

        const OCULUS_TOUCH_AXIS_X = 0;
        const OCULUS_TOUCH_AXIS_Y = 1;

        const OCULUS_TOUCH_BUTTON_STICK = 0;
        const OCULUS_TOUCH_BUTTON_TRIGGER = 1;
        const OCULUS_TOUCH_BUTTON_GRIP = 2
        const OCULUS_TOUCH_BUTTON_A_X = 3;
        const OCULUS_TOUCH_BUTTON_B_Y = 4;


        let lastVal = Date.now();
        function getDeltaTime() {
	        const newVal = Date.now();
            const result = newVal - lastVal;
            lastVal = newVal;
            return result / 1000;
        }

        let controllersButtonsOld = [];

        function mainloop() {
            const delta = Math.min(0.1, getDeltaTime());

            if (!document.pointerLockElement) {
                document.getElementById("menu").style.display = "";
            }

            if (newKeys["escape"]) { 
                //document.getElementById("menu").style.display = "";
                //document.exitPointerLock();

                //canvas.requestPointerLock();
                //document.getElementById("menu").style.display = "none";
            }

            if (newKeys["y"]) {
                activePlayer = defaultPlayer == activePlayer ? otherPlayer : defaultPlayer;
                updateUI();
                setActiveItem(activePlayer.activeItem);
            }

            const walkDirX = -Math.sin(activePlayer.rotation.yaw);
            const walkDirY =  Math.cos(activePlayer.rotation.yaw);

            const dirX = walkDirX * Math.cos(activePlayer.rotation.pitch);
            const dirY = walkDirY * Math.cos(activePlayer.rotation.pitch);
            const dirZ = Math.sin(activePlayer.rotation.pitch);

            const sideX = -Math.cos(activePlayer.rotation.yaw);
            const sideY = -Math.sin(activePlayer.rotation.yaw);

            let turnRate = 0;
            let pitchRate = 0;
            let walkX = 0;
            let walkY = 0;

            let jump = false;
            let shouldDig = false;
            let shouldPlace = false;
            let shouldThrow = false;

            var curWalkSpeed = walkSpeed;
            if (keys["shift"]) curWalkSpeed *= 2.0;

            if (keys["arrowleft"]) turnRate += 1;
            if (keys["arrowright"]) turnRate -= 1;

            if (keys["w"] || keys["arrowup"]) { walkX += walkDirX; walkY += walkDirY; }
            if (keys["s"] || keys["arrowdown"]) { walkX -= walkDirX; walkY -= walkDirY; }

            if (keys["a"]) { walkX += sideX; walkY += sideY; }
            if (keys["d"]) { walkX -= sideX; walkY -= sideY; }
        
            if (newKeys["backspace"] || clickLeft) shouldDig = true;
            if (clickRight) shouldPlace = true;

            if (newKeys[" "]) jump = true;
            if (newKeys["t"]) shouldThrow = true;

            if (keys["1"]) { activePlayer.activeItem = 0; setActiveItem(activePlayer.activeItem); }
            if (keys["2"]) { activePlayer.activeItem = 1; setActiveItem(activePlayer.activeItem); }
            if (keys["3"]) { activePlayer.activeItem = 2; setActiveItem(activePlayer.activeItem); }
            if (keys["4"]) { activePlayer.activeItem = 3; setActiveItem(activePlayer.activeItem); }
            if (keys["5"]) { activePlayer.activeItem = 4; setActiveItem(activePlayer.activeItem); }
            if (keys["6"]) { activePlayer.activeItem = 5; setActiveItem(activePlayer.activeItem); }
            if (keys["7"]) { activePlayer.activeItem = 6; setActiveItem(activePlayer.activeItem); }
            if (keys["8"]) { activePlayer.activeItem = 7; setActiveItem(activePlayer.activeItem); }

            if (newKeys["["]) { 
                activePlayer.activeItem -= 1;
                while (activePlayer.activeItem < 0) activePlayer.activeItem += 8;
                setActiveItem(activePlayer.activeItem);
            }
            if (newKeys["]"]) {  
                activePlayer.activeItem += 1;
                while (activePlayer.activeItem >= 8) activePlayer.activeItem -= 8;
                setActiveItem(activePlayer.activeItem);
            }

            if (newKeys["z"]) topView = !topView;

            if (newKeys["i"]) {
                var inventoryMenu = document.getElementById("inventoryMenu");

                if (inventoryMenu.style.display == "none") {
                    inventoryMenu.style.display = "";
                    document.exitPointerLock();
                } else {
                    inventoryMenu.style.display = "none";
                    canvas.requestPointerLock();
                }
            }



            //  https://github.com/360Controller/360Controller/

            const gamepads = navigator.getGamepads();
            for (let i=0; i<gamepads.length; i++) {
                const gamepad = gamepads[i];
                if (gamepad) {
                    if (!controllersButtonsOld[gamepad.index])
                        controllersButtonsOld[gamepad.index] = {};
                    let controllerButtonsOld = controllersButtonsOld[gamepad.index];

                    //console.log(gamepad);
                    // Xbox One:
                    //  axes:
                    //    left x; right: 1
                    //    left y; down: 1
                    //    right x; right: 1
                    //    right y; down: 1
                    //
                    //  buttons:
                    //    A           :  0
                    //    B           :  1
                    //    X           :  2
                    //    Y           :  3
                    //    LR          :  4
                    //    RR          :  5
                    //    LT          :  6 (analog)
                    //    RT          :  7 (analog)
                    //    View/Back   :  8
                    //    Menu/Start  :  9
                    //    Left stick  : 10
                    //    Right strick: 11
                    //    Up          : 12
                    //    Down        : 13
                    //    Left        : 14
                    //    Right       : 15
                    //    XBox Button : 16
                    //
                    //  https://github.com/360Controller/360Controller/
                    //  ^ is this one even needed????

                    const rescaled = (val) => Math.abs(val) > 0.2 ? val : 0;
                    const isNewPressed = (button) => gamepad.buttons[button].pressed && !controllerButtonsOld[button];

                    if (gamepad.id.startsWith("Xbox One")) {
                        walkX += -rescaled(gamepad.axes[XBOX_CONTROLLER_AXIS_LEFT_X]) * sideX;
                        walkY += -rescaled(gamepad.axes[XBOX_CONTROLLER_AXIS_LEFT_X]) * sideY;
                        walkX += -rescaled(gamepad.axes[XBOX_CONTROLLER_AXIS_LEFT_Y]) * walkDirX;
                        walkY += -rescaled(gamepad.axes[XBOX_CONTROLLER_AXIS_LEFT_Y]) * walkDirY;
                        
                        turnRate += -rescaled(gamepad.axes[XBOX_CONTROLLER_AXIS_RIGHT_X]);
                        pitchRate += -rescaled(gamepad.axes[XBOX_CONTROLLER_AXIS_RIGHT_Y]);

                        jump = jump || isNewPressed(XBOX_CONTROLLER_BUTTON_A);
                        shouldThrow = shouldThrow || isNewPressed(XBOX_CONTROLLER_BUTTON_B);

                        shouldPlace = shouldPlace || isNewPressed(XBOX_CONTROLLER_BUTTON_LT);
                        shouldDig = shouldDig || isNewPressed(XBOX_CONTROLLER_BUTTON_RT);

                        if (isNewPressed(XBOX_CONTROLLER_BUTTON_LB)) {
                            activePlayer.activeItem -= 1;
                            while (activePlayer.activeItem < 0) activePlayer.activeItem += 8;
                            setActiveItem(activePlayer.activeItem);
                        }

                        if (isNewPressed(XBOX_CONTROLLER_BUTTON_RB)) {
                            activePlayer.activeItem += 1;
                            while (activePlayer.activeItem >= 8) activePlayer.activeItem -= 8;
                            setActiveItem(activePlayer.activeItem);
                        }                        
                    }

                    gamepad.buttons.forEach((button, index) => {
                        controllerButtonsOld[index] = button.pressed;
                    });
                }
            }

            walkDist = Math.hypot(walkX, walkY);
            if (walkDist > 0.01) { // TODO: why is this not 1.0?????
                walkX /= walkDist;
                walkY /= walkDist;
            }

            if (jump) {
                activePlayer.velocity = {x: 0, y: 0, z: 10};
                activePlayer.standing = false;
            }

            if (shouldThrow) {
                activeInventory = activePlayer.inventory[activePlayer.activeItem];
                
                if (activeInventory && activeInventory.blockCount >= 1) {
                    const newEntity = {
                        type: ENTITY_TYPE_ITEM,
                        pos: {x: activePlayer.pos.x, y: activePlayer.pos.y, z: activePlayer.pos.z + activePlayer.eyeHeight},
                        rotation: {pitch: 0, yaw: 0},
                        acceleration: { x: 0, y: 0, z: -30.0},
                        velocity: { x: dirX * 10, y: dirY * 10, z: dirZ * 10},
                        height: 0.4,
                        radius: 0.2,
                        blockType: activeInventory.blockType,
                        blockCount: 1,
                    };

                    activeInventory.blockCount -= 1;

                    if (activeInventory.blockCount <= 0) {
                        activePlayer.inventory[activePlayer.activeItem] = null;
                    }

                    updateUI();

                    entities.push(newEntity);
                }
            }

            activePlayer.rotation.yaw += Math.min(1, turnRate) * turnSpeed;
            activePlayer.rotation.pitch += Math.min(1, pitchRate) * turnSpeed;
            activePlayer.rotation.pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, activePlayer.rotation.pitch));

            activePlayer.pos.x += walkX * curWalkSpeed;
            activePlayer.pos.y += walkY * curWalkSpeed;

            updateAll(delta);



            const cameraX = activePlayer.pos.x;
            const cameraY = activePlayer.pos.y;
            const cameraZ = activePlayer.pos.z + activePlayer.eyeHeight;

            


            const rayResult = traceRay(cameraX, cameraY, cameraZ, dirX, dirY, dirZ, 20);

            document.getElementById("position").innerText = "activePlayer: X: " + activePlayer.pos.x.toFixed(3) + ", Y: " + activePlayer.pos.y.toFixed(3) + ", Z:" + activePlayer.pos.z.toFixed(3);
            document.getElementById("rotation").innerText = "Yaw: " + (activePlayer.rotation.yaw / (Math.PI/180)).toFixed(0) + ",  Pitch: " + (activePlayer.rotation.pitch / (Math.PI/180)).toFixed(0);
            document.getElementById("cursor").innerText = "cursor: X: " + rayResult.cursor.x.toFixed(3) + ", Y: " + rayResult.cursor.y.toFixed(3) + ", Z:" + rayResult.cursor.z.toFixed(3);

            document.getElementById("acceleration").innerText = "acceleration: X: " + activePlayer.acceleration.x.toFixed(3) + ", Y: " + activePlayer.acceleration.y.toFixed(3) + ", Z:" + activePlayer.acceleration.z.toFixed(3);
            document.getElementById("velocity").innerText = "velocity: X: " + activePlayer.velocity.x.toFixed(3) + ", Y: " + activePlayer.velocity.y.toFixed(3) + ", Z:" + activePlayer.velocity.z.toFixed(3);

            if (shouldPlace) {
                activeInventory = activePlayer.inventory[activePlayer.activeItem];

                if (activeInventory) {
                    world.setBlock(rayResult.prevCursor.x, rayResult.prevCursor.y, rayResult.prevCursor.z, activeInventory.blockType);
                    activeInventory.blockCount -= 1;

                    if (activeInventory.blockCount <= 0) {
                        activePlayer.inventory[activePlayer.activeItem] = null;
                    }
                    updateUI();
                }
            }

            if (shouldDig) {
                const blockType = world.getBlock(rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z);
                world.setBlock(rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z, 0);

                const newEntity = {
                    type: ENTITY_TYPE_ITEM,
                    pos: {x: rayResult.cursor.x + 0.5, y: rayResult.cursor.y + 0.5, z: rayResult.cursor.z},
                    rotation: {pitch: 0, yaw: 0},
                    acceleration: { x: 0, y: 0, z: -30.0},
                    velocity: { x: 0, y: 0, z: 5},
                    height: 0.4,
                    radius: 0.2,
                    blockType: blockType,
                    blockCount: 1,
                };
                entities.push(newEntity);
            }

            clickLeft = false;
            clickRight = false;

            

            var projection = mat4.getProjection(canvas.width/canvas.height, fov * (Math.PI/180), 0.1, Math.max((renderDistance+1) * 16, 500));
            var camera = mat4.multiply(mat4.getTranslate(-cameraX,-cameraZ,cameraY), mat4.multiply(mat4.getYRotation(activePlayer.rotation.yaw), mat4.getXRotation(-activePlayer.rotation.pitch)));




            //gl.clearColor(0.8, 0.8, 1.0, 1.0);
            //gl.clearColor(0, 0.75, 1.0, 1.0);
            gl.enable(gl.STENCIL_TEST); 
            gl.clearStencil(0);
            gl.stencilMask(0xFF);
            gl.clearColor(world.backgroundColor[0], world.backgroundColor[1], world.backgroundColor[2], 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            draw(projection, camera, cameraX, cameraY, rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z);
            



            
            newKeys = {};
        }

        /*
        let debugCanvas = document.createElement("canvas");
        debugCanvas.width = 512;
        debugCanvas.height = 512;

        debugCanvas.style = "width: 512px; height: 512px; right: 0px; top: 0px; position: absolute; image-rendering: pixelated;";
        document.body.appendChild(debugCanvas);

        debugCanvas.getContext("2d").translate(256,256);*/
        







        function draw(projectionMatrix, viewMatrix, cameraX, cameraY, cursorX, cursorY, cursorZ) {
            // TODO (maybe): get cameraX and cameraY from viewMatrix


            
            


            
            const inverseProjection = mat4.inverse(mat4.multiply(viewMatrix, projectionMatrix));

            const frustumData = [
                [-1, -1,  -1, 1],
                [ 1, -1,  -1, 1],
                [-1,  1,  -1, 1],
                [ 1,  1,  -1, 1],
                [-1, -1,   1, 1],
                [ 1, -1,   1, 1],
                [-1,  1,   1, 1],
                [ 1,  1,   1, 1]]
            .map(pos => mat4.multiply(inverseProjection, pos))
            .map(pos => [pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]]);

            for (let i=0; i<4; i++) {
                const a = frustumData[i];
                const b = frustumData[i+4];

                if (a[1] > 0 && b[1] < 0) {
                    const t = a[1] / (a[1]-b[1]);
                    frustumData[i+4] = vec3.lerp(a, b, t);
                }
            }

            
            const frustumLineDist = function(a, b, p) {
                const p1 = [frustumData[a][0], frustumData[a][2]];
                const p2 = [frustumData[b][0], frustumData[b][2]];
                //const p = [chunkX + 8, chunkY + 8];

                const len = vec2.length(vec2.subtract(p2,p1));

                // TODO: seems this gives some issues sometimes (render chunks that are not in view along some line)
                const chunkRadius = 11.4; // = slightly bigger then radius of chunk circle (8 + 8)

                const dist = (vec2.cross(vec2.subtract(p2,p1), vec2.subtract(p, p1)) / len) + chunkRadius;
                return dist;
            }

/*
            let debugCtx = debugCanvas.getContext("2d");
            debugCtx.clearRect(-256, -256, debugCtx.canvas.width, debugCtx.canvas.height);


            for (let x=-16; x<16; x++)
                for (let y=-16; y<16; y++) {
                    const chunkX = x*16;
                    const chunkY = y*16;

                    const p = [chunkX + 8, chunkY + 8];

                    var inMiddle = 
                        (frustumLineDist(5,4, p) >= 0) && 
                        (frustumLineDist(6,7, p) >= 0) && 
                        (frustumLineDist(4,6, p) >= 0) &&
                        (frustumLineDist(7,5, p) >= 0);

                    var inMiddleReverse = 
                        (frustumLineDist(4,5, p) >= 0) && 
                        (frustumLineDist(7,6, p) >= 0) && 
                        (frustumLineDist(6,4, p) >= 0) &&
                        (frustumLineDist(5,7, p) >= 0);

                    var inBottom = 
                        (frustumLineDist(4,5, p) >= 0) && 
                        (frustumLineDist(1,0, p) >= 0) && 
                        (frustumLineDist(0,4, p) >= 0) && 
                        (frustumLineDist(5,1, p) >= 0);

                    var inTop = 
                        (frustumLineDist(6,7, p) >= 0) && 
                        (frustumLineDist(3,2, p) >= 0) && 
                        (frustumLineDist(2,6, p) >= 0) && 
                        (frustumLineDist(7,3, p) >= 0);
                    

                    if (inMiddle || inMiddleReverse || inBottom || inTop) {
                        debugCtx.fillStyle = "#00000088";
                        debugCtx.fillRect(chunkX, chunkY, 16, 16);
                    }
                }


            // Draw chunk grid
            debugCtx.strokeStyle = "#aaaaaa";
            debugCtx.beginPath();
            for (let i=-256; i<=256; i+=16) {            
                debugCtx.moveTo(i, -256);
                debugCtx.lineTo(i,  256);

                debugCtx.moveTo(-256, i);
                debugCtx.lineTo( 256, i);
            }
            debugCtx.stroke();

            // Draw 0 axis
            debugCtx.strokeStyle = "#ffffff";
            debugCtx.beginPath();
            debugCtx.moveTo(0, -256);
            debugCtx.lineTo(0,  256);

            debugCtx.moveTo(-256, 0);
            debugCtx.lineTo( 256, 0);
            debugCtx.stroke();

            debugCtx.strokeStyle = "#ff0000";
            debugCtx.beginPath();
            debugCtx.moveTo(frustumData[0][0], frustumData[0][2]);
            debugCtx.lineTo(frustumData[1][0], frustumData[1][2]);
            debugCtx.lineTo(frustumData[5][0], frustumData[5][2]);
            debugCtx.lineTo(frustumData[4][0], frustumData[4][2]);
            debugCtx.closePath();
            debugCtx.stroke();

            debugCtx.strokeStyle = "#00ff00";
            debugCtx.beginPath();
            debugCtx.moveTo(frustumData[2][0], frustumData[2][2]);
            debugCtx.lineTo(frustumData[3][0], frustumData[3][2]);
            debugCtx.lineTo(frustumData[7][0], frustumData[7][2]);
            debugCtx.lineTo(frustumData[6][0], frustumData[6][2]);
            debugCtx.closePath();
            debugCtx.stroke();

            debugCtx.strokeStyle = "#ffff00";
            debugCtx.beginPath();
            debugCtx.moveTo(frustumData[4][0], frustumData[4][2]);
            debugCtx.lineTo(frustumData[6][0], frustumData[6][2]);
            debugCtx.moveTo(frustumData[5][0], frustumData[5][2]);
            debugCtx.lineTo(frustumData[7][0], frustumData[7][2]);
            debugCtx.stroke();
*/

            if (topView) {





                var frustumBufferDataArray = [];

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[0]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[1]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[1]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[3]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[3]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[2]);
                
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[2]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[0]);
 

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[0]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[4]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[1]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[5]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[2]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[6]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[3]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[7]);


                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[4]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[5]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[5]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[7]);

                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[7]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[6]);
                
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[6]);
                var frustumBufferDataArray = frustumBufferDataArray.concat(frustumData[4]);


                var frustumBufferData = new Float32Array(frustumBufferDataArray);

                gl.bindBuffer(gl.ARRAY_BUFFER, frustumBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, frustumBufferData, gl.STATIC_DRAW);

                renderFrustum = frustumBufferDataArray.length / 3;
            } else {
                renderFrustum = false;
            }


            if (topView) {
                // Have some debug top-down view.
                // Frustum culling still assumes the matrices given as parameters.
                viewMatrix = mat4.multiply(mat4.getTranslate(-cameraX,-28 * renderDistance,cameraY), mat4.getXRotation(Math.PI * 0.5));
                projectionMatrix = mat4.getProjection(canvas.width/canvas.height, 70 * (Math.PI/180), 0.1, 2000);
            }

            let chunksRegenerated = 0;

            gl.useProgram(program);
            if (topView) {
                gl.uniform1f(program.u_fogStart, 500);
                gl.uniform1f(program.u_fogEnd, 500);
            } else {
                gl.uniform1f(program.u_fogStart, (renderDistance-4)*16);
                gl.uniform1f(program.u_fogEnd, 4*16);
            }

            gl.uniformMatrix4fv(program.u_projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(program.u_viewMatrix, false, viewMatrix);
            //gl.uniformMatrix4fv(u_modelMatrix, false, rotation);


            gl.uniform3f(program.u_backgroundColor, world.backgroundColor[0], world.backgroundColor[1], world.backgroundColor[2]);

            gl.enableVertexAttribArray(program.a_position);
            gl.enableVertexAttribArray(program.a_texCoord);
            gl.enableVertexAttribArray(program.a_normal);

            const renderDistanceBlocks = renderDistance + 2;
            const halfPi = Math.PI / 2.0;

            const blaX = Math.floor(cameraX/16);
            const blaY = Math.floor(cameraY/16);

            let renderedChunks = 0;
            let renderedElements = 0;
            for (var y=-renderDistanceBlocks+blaY; y<=renderDistanceBlocks+blaY; y++)
                for (var x=-renderDistanceBlocks+blaX; x<=renderDistanceBlocks+blaX; x++) {
                    
                    // chunk center
                    const p = [x*16 + 8, -(y*16 + 8)];

                    var inMiddle = 
                        (frustumLineDist(5,4, p) >= 0) && 
                        (frustumLineDist(6,7, p) >= 0) && 
                        (frustumLineDist(4,6, p) >= 0) &&
                        (frustumLineDist(7,5, p) >= 0);

                    var inMiddleReverse = 
                        (frustumLineDist(4,5, p) >= 0) && 
                        (frustumLineDist(7,6, p) >= 0) && 
                        (frustumLineDist(6,4, p) >= 0) &&
                        (frustumLineDist(5,7, p) >= 0);

                    var inBottom = 
                        (frustumLineDist(4,5, p) >= 0) && 
                        (frustumLineDist(1,0, p) >= 0) && 
                        (frustumLineDist(0,4, p) >= 0) && 
                        (frustumLineDist(5,1, p) >= 0);

                    var inTop = 
                        (frustumLineDist(6,7, p) >= 0) && 
                        (frustumLineDist(3,2, p) >= 0) && 
                        (frustumLineDist(2,6, p) >= 0) && 
                        (frustumLineDist(7,3, p) >= 0);
                    

                    if (!(inMiddle || inMiddleReverse || inBottom || inTop)) {
                        continue;
                    }




                    //const angle = Math.atan2(x,y) / (Math.PI / 180);

                    const x2 = x - cameraX/16;
                    const y2 = y - cameraY/16;

                    if (Math.hypot(x2,y2) > renderDistance) continue;

                    //const x3 = x2 * Math.cos(-activePlayer.rotation.yaw) - y2 * Math.sin(-activePlayer.rotation.yaw);
                    //const y3 = y2 * Math.cos(-activePlayer.rotation.yaw) + x2 * Math.sin(-activePlayer.rotation.yaw);

                    //const angle = Math.atan2(x3,y3);// / (Math.PI / 180);


                    //if (angle < -halfPi || angle > halfPi) continue;


                    //console.log("draw chunk: ", x, y);

                    const chunk = world.findChunk(x, y);

                    if (!chunk) continue;

                    if (chunk.dirty) {

                        if (chunksRegenerated > 20) continue;

                        chunksRegenerated++;
                        if (!updateChunkBuffer(chunk))
                            continue;
                    }


                    gl.bindBuffer(gl.ARRAY_BUFFER, chunk.buffer);
                    gl.vertexAttribPointer(program.a_position, 3, gl.FLOAT, false, 8 * 4, 0);
                    gl.vertexAttribPointer(program.a_texCoord, 2, gl.FLOAT, false, 8 * 4, 3 * 4);
                    gl.vertexAttribPointer(program.a_normal, 3, gl.FLOAT, false, 8 * 4, 5 * 4);
                    

                    gl.uniformMatrix4fv(program.u_modelMatrix, false, mat4.getTranslate(x*16,0,-y*16));

                    gl.drawArrays(gl.TRIANGLES, 0, chunk.elementCount);

                    renderedChunks++;
                    renderedElements+= chunk.elementCount;
                }

            document.getElementById("renderedChunks").innerText = "Rendered chunks: " + renderedChunks + ";  Triangles: " + (renderedElements/3);

            



            for (const entity of entities) {
                if (entity == activePlayer) continue;

                let mesh = null;
                let scale = 1.0;
                let zOffset = 0.0;

                if (entity.type == ENTITY_TYPE_ITEM) {
                    const someItem = blockTypes[entity.blockType];
                    mesh = someItem ? someItem.mesh : null;

                    scale = 4.0;
                    zOffset = 0.2;
                    gl.bindTexture(gl.TEXTURE_2D, atlas);
                }

                if (entity.type == ENTITY_TYPE_PLAYER) {
                    gl.bindTexture(gl.TEXTURE_2D, entity.skin);
                    scale = 0.5625;
                    mesh = steveMesh;
                }

                
                
                if (mesh) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                    gl.vertexAttribPointer(program.a_position, 3, gl.FLOAT, false, 8 * 4, 0);
                    gl.vertexAttribPointer(program.a_texCoord, 2, gl.FLOAT, false, 8 * 4, 3 * 4);
                    gl.vertexAttribPointer(program.a_normal, 3, gl.FLOAT, false, 8 * 4, 5 * 4);

                    const modelMatrix = mat4.multiply(
                        mat4.getYRotation(-entity.rotation.yaw),
                        mat4.multiply(
                                mat4.getScale(scale, scale, scale), 
                                mat4.getTranslate(entity.pos.x, entity.pos.z + zOffset, -entity.pos.y))
                        )

                    gl.uniformMatrix4fv(program.u_modelMatrix, false, modelMatrix);
                    
                    if (mesh.indexBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);

                        gl.drawElements(gl.TRIANGLES, mesh.elementCount, gl.UNSIGNED_BYTE, 0);
                    } else {
                        gl.drawArrays(gl.TRIANGLES, 0, mesh.elementCount);
                    }
                }
            }

            gl.bindTexture(gl.TEXTURE_2D, atlas);


            // ===[ Draw 3D cursor ]===
            if (cursorZ >= 0 && cursorZ <= 127) {
                gl.enable(gl.BLEND);
                gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                gl.useProgram(frustumProgram);

                gl.uniformMatrix4fv(frustumProgram.u_projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(frustumProgram.u_viewMatrix, false, viewMatrix);
                gl.uniformMatrix4fv(frustumProgram.u_modelMatrix, false, mat4.getTranslate(cursorX,cursorZ,-cursorY));

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer3);

                gl.enableVertexAttribArray(frustumProgram.a_position);
                gl.vertexAttribPointer(frustumProgram.a_position, 3, gl.FLOAT, false, 3 * 4, 0);


                gl.uniform4f(frustumProgram.u_color, 0,0,0,1);
                gl.drawElements(gl.LINES, 8*3, gl.UNSIGNED_BYTE, 12*3);
                gl.uniform4f(frustumProgram.u_color, 0,0,1,0.5);
                gl.drawElements(gl.TRIANGLES, 6*6, gl.UNSIGNED_BYTE, 0);

                gl.disable(gl.BLEND);
            }


            // ===[ Draw equiped item ]===
            const activeInventory = activePlayer.inventory[activePlayer.activeItem];
            if (activeInventory) {
                const activeToolItem = blockTypes[activeInventory.blockType];
                if (activeToolItem && activeToolItem.mesh) {

                    //gl.disable(gl.BLEND);

                    gl.useProgram(program);

                    gl.uniformMatrix4fv(program.u_projectionMatrix, false, projectionMatrix);
                    gl.uniformMatrix4fv(program.u_viewMatrix, false, mat4.getIdentity());
                    //gl.uniformMatrix4fv(program.u_modelMatrix, false, mat4.multiply(equipHandMatrix, mat4.getTranslate(0, 0, -3)));
                    gl.uniformMatrix4fv(program.u_modelMatrix, false, equipHandMatrix);

                    gl.enableVertexAttribArray(program.a_position);
                    gl.enableVertexAttribArray(program.a_texCoord);
                    gl.enableVertexAttribArray(program.a_normal);

                    gl.bindBuffer(gl.ARRAY_BUFFER, activeToolItem.mesh.vertexBuffer);
                    gl.vertexAttribPointer(program.a_position, 3, gl.FLOAT, false, 8 * 4, 0);
                    gl.vertexAttribPointer(program.a_texCoord, 2, gl.FLOAT, false, 8 * 4, 3 * 4);
                    gl.vertexAttribPointer(program.a_normal, 3, gl.FLOAT, false, 8 * 4, 5 * 4);

                    

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, activeToolItem.mesh.indexBuffer);

                    gl.drawElements(gl.TRIANGLES, 6*6, gl.UNSIGNED_BYTE, 0);
                }
            }


            if (renderFrustum) {
                gl.useProgram(frustumProgram);

                gl.uniformMatrix4fv(frustumProgram.u_projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(frustumProgram.u_viewMatrix, false, viewMatrix);
                gl.uniformMatrix4fv(frustumProgram.u_modelMatrix, false, mat4.getIdentity());

                gl.lineWidth(25.0);
                gl.bindBuffer(gl.ARRAY_BUFFER, frustumBuffer);
                gl.enableVertexAttribArray(frustumProgram.a_position);
                gl.vertexAttribPointer(frustumProgram.a_position, 3, gl.FLOAT, false, 3 * 4, 0);

                gl.depthFunc(gl.ALWAYS);
                gl.depthMask(false);

                gl.uniform4f(frustumProgram.u_color, 0,0,0,0.3);
                gl.drawArrays(gl.LINES, 0, renderFrustum);

                gl.depthFunc(gl.LESS);
                gl.depthMask(true);

                gl.uniform4f(frustumProgram.u_color, 0,0,0,1);
                gl.drawArrays(gl.LINES, 0, renderFrustum);

                gl.depthFunc(gl.LESS);
            }

            time += 0.1;

        }

        function drawHandler() {
            equipHandMatrix = mat4.getTranslate(0.4,-0.2,-0.3);
            mainloop();
            window.requestAnimationFrame(drawHandler);
        }

        window.requestAnimationFrame(drawHandler);


        


    </script>
    <div id="vr-icon" style="display: none; position: absolute; right: 10px; bottom: 10px; width: 100px; height: 70px; background-image: url('cardboard-logo_2x.png'); background-position: center center; background-repeat: no-repeat;">

    </div>
    <script>
        var equipHandMatrix = mat4.getYRotation(0.2);

        function matrixFromPose(pose) {
            return mat4.multiply(
                mat4.fromQuaternion(pose.orientation),
                mat4.getTranslate(pose.position[0], pose.position[1], pose.position[2]));
        }

        if (navigator.getVRDisplays) {
            navigator.getVRDisplays().then(displays => {

                if (displays.length > 0) {
                    let display = displays[0];

                    const vrIcon = document.getElementById('vr-icon');

                    vrIcon.onclick = (e) => {
                        display.requestPresent([{source: canvas}]).then(val => {

                            var leftEye = display.getEyeParameters("left");
                            var rightEye = display.getEyeParameters("right");

                            canvas.width = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
                            canvas.height = Math.max(leftEye.renderHeight, rightEye.renderHeight);



                            drawHandler = () => {};

                            let frameData = new VRFrameData();

                            // Hold button states to detect first press
                            let nextItemPressed = false;
                            let prevItemPressed = false;
                            let placePressed = false;
                            let digPressed = false;



                            function vrDrawHandler() {
                                if (!display.isPresenting) return;

                                const delta = Math.min(0.1, getDeltaTime());

                                const walkDirX = -Math.sin(activePlayer.rotation.yaw);
                                const walkDirY =  Math.cos(activePlayer.rotation.yaw);

                                var dirX = walkDirX * Math.cos(activePlayer.rotation.pitch);
                                var dirY = walkDirY * Math.cos(activePlayer.rotation.pitch);
                                var dirZ = Math.sin(activePlayer.rotation.pitch);

                                var sideX = -Math.cos(activePlayer.rotation.yaw);
                                var sideY = -Math.sin(activePlayer.rotation.yaw);


                                let turnRate = 0;
                                let walkX = 0;
                                let walkY = 0;

                                let jump = false;
                                let shouldDig = false;
                                let shouldPlace = false;
                                let shouldThrow = false;

                                // Left controller:
                                // X: Crouch
                                // Y: Toggle 2D/3D
                                // Trigger: Next item
                                // Grip: Prev item
                                // Thumbstick: Move
                                // Press Thumbstick: Nothing

                                // Right controller:
                                // A: jump
                                // B: show inventory
                                // Trigger: dig/use
                                // Grip: Place block
                                // Thumbstick: Rotate
                                // Press Thumbstick: throw item






                                const gamepads = navigator.getGamepads();
                                for (let i=0; i<gamepads.length; i++) {
                                    const gamepad = gamepads[i];
                                    if (gamepad) {
                                        if (!controllersButtonsOld[gamepad.index])
                                            controllersButtonsOld[gamepad.index] = {};
                                        let controllerButtonsOld = controllersButtonsOld[gamepad.index];

                                        const isNewPressed = (button) => gamepad.buttons[button].pressed && !controllerButtonsOld[button];

                                        if (gamepad.id == OCULUS_TOUCH_ID_LEFT) {
                                            walkX += -gamepad.axes[OCULUS_TOUCH_AXIS_Y] * walkDirX;
                                            walkY += -gamepad.axes[OCULUS_TOUCH_AXIS_Y] * walkDirY;

                                            walkX += -gamepad.axes[OCULUS_TOUCH_AXIS_X] * sideX;
                                            walkY += -gamepad.axes[OCULUS_TOUCH_AXIS_X] * sideY;

                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_TRIGGER)) {
                                                activePlayer.activeItem += 1;
                                                while (activePlayer.activeItem >= 8) activePlayer.activeItem -= 8;
                                                setActiveItem(activePlayer.activeItem);
                                            }

                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_GRIP)) {
                                                activePlayer.activeItem -= 1;
                                                while (activePlayer.activeItem < 0) activePlayer.activeItem += 8;
                                                setActiveItem(activePlayer.activeItem);
                                            }

                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_B_Y)) {
                                                activePlayer = defaultPlayer == activePlayer ? otherPlayer : defaultPlayer;
                                                updateUI();
                                                setActiveItem(activePlayer.activeItem);
                                            }
                                        }

                                        if (gamepad.id == OCULUS_TOUCH_ID_RIGHT) {
                                            turnRate += -gamepad.axes[OCULUS_TOUCH_AXIS_X];

                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_STICK)) shouldThrow = true;
                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_TRIGGER)) shouldDig = true;
                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_GRIP)) shouldPlace = true;
                                            if (isNewPressed(OCULUS_TOUCH_BUTTON_A_X)) jump = true;

                                            if (gamepad.buttons[OCULUS_TOUCH_BUTTON_B_Y].pressed) display.exitPresent();

                                            equipHandMatrix = matrixFromPose(gamepad.pose);
                                        } 
                                        



                                        gamepad.buttons.forEach((button, index) => {
                                            controllerButtonsOld[index] = button.pressed;
                                        });
                                    }
                                };

                                walkLen = Math.hypot(walkX, walkY);
                                if (walkLen > 1.0) {
                                    walkX /= walkLen;
                                    walkY /= walkLen;
                                }

                                if (jump) {
                                    activePlayer.velocity = {x: 0, y: 0, z: 10}; 
                                    activePlayer.standing = false;
                                }

                                if (shouldThrow) {
                                    activeInventory = activePlayer.inventory[activePlayer.activeItem];
                                    
                                    if (activeInventory && activeInventory.blockCount >= 1) {
                                        const newEntity = {
                                            type: ENTITY_TYPE_ITEM,
                                            pos: {x: activePlayer.pos.x, y: activePlayer.pos.y, z: activePlayer.pos.z + activePlayer.eyeHeight},
                                            rotation: {pitch: 0, yaw: 0},
                                            acceleration: { x: 0, y: 0, z: -30.0},
                                            velocity: { x: dirX * 10, y: dirY * 10, z: dirZ * 10},
                                            height: 0.4,
                                            radius: 0.2,
                                            blockType: activeInventory.blockType,
                                            blockCount: 1,
                                        };

                                        activeInventory.blockCount -= 1;

                                        if (activeInventory.blockCount <= 0) {
                                            activePlayer.inventory[activePlayer.activeItem] = null;
                                        }

                                        updateUI();

                                        entities.push(newEntity);
                                    }
                                }
                                


                                activePlayer.rotation.yaw += turnRate * turnSpeed;

                                activePlayer.pos.x += walkX * walkSpeed;
                                activePlayer.pos.y += walkY * walkSpeed;


                                updateAll(delta);


                                const cameraX = activePlayer.pos.x;
                                const cameraY = activePlayer.pos.y;
                                const cameraZ = activePlayer.pos.z + 1.65;


                                

                                var cameraInverse = mat4.multiply(mat4.getTranslate(-cameraX,-cameraZ,cameraY), mat4.getYRotation(activePlayer.rotation.yaw));
                                
                                var camera = mat4.multiply(mat4.getYRotation(-activePlayer.rotation.yaw), mat4.getTranslate(cameraX,cameraZ,-cameraY));

                                var worldEquipHandMatrix = mat4.multiply(equipHandMatrix, camera);

                                
                                

                                const handPosX =  worldEquipHandMatrix[12];
                                const handPosY = -worldEquipHandMatrix[14];
                                const handPosZ =  worldEquipHandMatrix[13];

                                const handDirX = -worldEquipHandMatrix[ 8];
                                const handDirY =  worldEquipHandMatrix[10];
                                const handDirZ = -worldEquipHandMatrix[ 9];

                                const rayResult = traceRay(handPosX, handPosY, handPosZ, handDirX, handDirY, handDirZ, 80);
                                

                                if (shouldPlace) {
                                    activeInventory = activePlayer.inventory[activePlayer.activeItem];

                                    if (activeInventory) {
                                        world.setBlock(rayResult.prevCursor.x, rayResult.prevCursor.y, rayResult.prevCursor.z, activeInventory.blockType);
                                        activeInventory.blockCount -= 1;

                                        if (activeInventory.blockCount <= 0) {
                                            activePlayer.inventory[activePlayer.activeItem] = null;
                                        }
                                        updateUI();
                                    }
                                }

                                if (shouldDig) {
                                    const blockType = world.getBlock(rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z);
                                    world.setBlock(rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z, 0);

                                    const newEntity = {
                                        type: ENTITY_TYPE_ITEM,
                                        pos: {x: rayResult.cursor.x + 0.5, y: rayResult.cursor.y + 0.5, z: rayResult.cursor.z},
                                        rotation: {pitch: 0, yaw: 0},
                                        acceleration: { x: 0, y: 0, z: -30.0},
                                        velocity: { x: 0, y: 0, z: 5},
                                        height: 0.4,
                                        radius: 0.2,
                                        blockType: blockType,
                                        blockCount: 1,
                                    };
                                    entities.push(newEntity);
                                }



                                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                                display.getFrameData(frameData);

                                var originalEquipHandMatrix = equipHandMatrix;

                                gl.viewport(0, 0, canvas.width/2, canvas.height);
                                equipHandMatrix = mat4.multiply(originalEquipHandMatrix, frameData.leftViewMatrix);
                                draw(frameData.leftProjectionMatrix, mat4.multiply(cameraInverse, frameData.leftViewMatrix), cameraX, cameraY, rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z);

                                gl.viewport(canvas.width/2, 0, canvas.width/2, canvas.height);
                                equipHandMatrix = mat4.multiply(originalEquipHandMatrix, frameData.rightViewMatrix);
                                draw(frameData.rightProjectionMatrix, mat4.multiply(cameraInverse, frameData.rightViewMatrix), cameraX, cameraY, rayResult.cursor.x, rayResult.cursor.y, rayResult.cursor.z);

                                display.submitFrame();

                                display.requestAnimationFrame(vrDrawHandler);
                            }

                            display.requestAnimationFrame(vrDrawHandler);
                        })

                    };

                    vrIcon.style.display = "";
                    console.log("VR Headset found:", display.displayName);
                }
            });
        }
    </script>
</body>
</html>